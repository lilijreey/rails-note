## Rails
 是一个全栈的MVC web 框架
rails new <name>
rails new <name> --skip-bundle ## 加快速度

 rails 对ruby 的内置类进行了修改
 e.g. String add blank?

rails s -b 0.0.0.0 绑定ip
        -p 7777 

production 模式
 see deployProduction.md 

background 后台运行Rails
-d 后台运行
1. nohup <cmd> &
   nohup rails s -e production
   pid 在/tmp/pids/server.pid

2.  rails s -d



## Rails 组件
#* DB->ROM ActiveRecord
#* 前端资源打包 AssetPipeline sprockets gem
#* Controller
#* 模板引擎
#* heapler 

## Qus.
 + CMS　系统
   comfortableMexicanSofa
   gem 'comfortable_mexican_sofa'
	Then from your Rails project's folder run these commands:
	bundle install
	rails generate comfy:cms
	rake db:migrate

1.   可以创建不同的站点
2. 可以自定义布局
   布局就是一个html 格局
   　可以在布局中引用　编辑的内容
   格式为: cms:<TagsType>:<Name>:<Tyep>
   每个{{}} 作为一个block 结构存在
e.g.
    {{ cms:page:header:string }}
    {{ cms:page:content:text }}
    {{ cms:page:another_block:rich_text }}
    {{ cms:page:content:rich_text }}


3 send_data
	data = "Hello World!"
	send_data( data, :filename => "my_file.txt" )
    把数据作为文件发送

TagsType:
  + page: 会render 到页面中
  + field: 不会render 到页面中，可以被helpers 通过cms_block_content("xx") 来访问
      可以用来传递参数，比如需要查找的所有页面的tag
  + snippet
  + helper:method_name 用来调用helper 方法
  + file 用来上传文件

  

  自定义布局，布局的内容通过自定义　{{cms:page:<field><type>}} 来添加
　　当你写cms:page:<FieldName><Type> 的时候
    只要页面中引用这个这个样式，就会被每一个Field一个编辑区域

   内容的引用使用namespace 开始都是cms:<



3. 可以使用片段
   {cms:snippet:<Name>}

5. 类别的使用
    页面和片段都可以使用类别
  在view 中访问指定类别
    - Comfy::Cms::Snippet.for_category('xx').each do |slide |
      
6. 在layout中调用插入app中的模板（render)
    {{ cms:partial:path/to/partial }}     # same as <%= render :partial => 'path/to/partial' %>
    {{ cms:partial:/enum_xx}}   # 渲染的文件为app/views/_enum_xx.html.erb

    

7. 在app中访问CMS的内容
      Comfy::Cms::File
      Comfy::Cms::Layout
      Comfy::Cms::Page
      这些都是ActiveRecord 的类型
      obj.block 得到对应的block ActiveRecord
      obj.block.tag 得到对应的Tag


      Comfy::Cms::Page.first 第一个文件
      Comfy::Cms::Page.first.blocks_attributes -> 得到本页的所有page:填充字段 Array()
      page.lable 得到页面标签
      page.blocks.find_by_identifier(:name).content
      helper: cms_block_content(:desc, pageObj) 访问指定的block

      得到所有同类型页面
      Comfy::Cms::Page.for_category


       访问file_image
       c.content.first.file.url

4. 可以上传文件


 + 如何开启temple cache

 +  404

  def render_403
    head :forbidden
  end

  def render_404
    #render file: Rails.root.join("public", "404"), layout: false, status: "404"
    render :file => 'public/404.html', layout: false, status: "404"
  end


 + 一般写在ApplicationContorller 中
  def no_cache_headers
    response.headers["Cache-Control"] = "no-cache, no-store, max-age=0, must-revalidate"
    response.headers["Pragma"] = "no-cache"
    response.headers["Expires"] = "Fri, 01 Jan 1990 00:00:00 GMT"
  end

  def default_headers
    headers['X-Frame-Options'] = 'DENY'
    headers['X-XSS-Protection'] = '1; mode=block'
    headers['X-UA-Compatible'] = 'IE=edge'
    headers['X-Content-Type-Options'] = 'nosniff'
    # Enabling HSTS for non-standard ports would send clients to the wrong port
    if Gitlab.config.gitlab.https and Gitlab.config.gitlab.port == 443
      headers['Strict-Transport-Security'] = 'max-age=31536000'
    end
  end

 + rescue_for类型与missing_method
    用于处理制定的异常，回调
	FooController < ActionController::Base
	  rescue_from ActiveRecord::RecordNotFound, with: not_found

	  private
	  def notfound
	    message = "Foo with ID #{params[:id]} not found."
	    logger.error message
	    redirect_to not_found_url, info: message
	  end
	end
    
     党在 FooController scope 里面生成一个RecordNotFound 异常后，
     就会调用 not_found

      ## 也可以直接写block
     rescue_from ActiveRecord::RecordNotFound do |exception|
	     message = "Foo with ID #{params[:id]} not found."
	     logger.error message
	     redirect_to not_found_url, info: message
     end
 + privilage safe

 + logout 
    new,delete session resource

    
 
 + Unpermitted 看看是不是controller的parmar 私有方法没有改变

 + CSRF
  #protect_from_forgery with: :exception
  protect_from_forgery with: :reset_session
   delete 时产生的原因
   模板生成错误
    - csrf_meta_tags
     改为
    = csrf_meta_tags


Rails 工具类
----------------------------
* str.underscore 驼峰转下划线
* HashWithIndifferentAccess 一个Hash容器,key, 不区分string 和symbol

Tools
----------------------------
generate scaffold Produce (单数) 
     生成的modelClass 为Produce, db table 为produces(复数)
generate module Produce (单数) 

Bundle
 一个自动安装分析rails app所依赖的gems 的工具
 Rails 本身依赖Bundle， 所以安装Rails的时候就已经自动安装bundle了

Gemfile
 可以制定一个环境
  .e.g group :development do
          gem xxxx
       end
       group :development, :test do
          gem xxxx
       end
   从git仓库，需要有xx.gemspce 文件
    gem 'carrierwave', github: 'jnicklas/carrierwave'
    gem 'carrierwave', github: 'jnicklas/carrierwave', ref => '339e'
    gem 'carrierwave', github: 'jnicklas/carrierwave', tag: 'xxx'
    gem 'carrierwave', github: 'jnicklas/carrierwave', branch: 'xxx'

   load gem from local file system
     gem 'xxx', paht: '~/xx/yy'

bundle install --without test
bundle package
     package all gems to vendor/cache
    再次安装就会直接使用vendor/cache中的安装, 用于离线安装
     bundle install vendor/cache/*

rake doc:app # 生成文档
rake state  # 代码统计


## 权限限制
使用 before_filter 回调方法实现
通关添加admin 字段来检测是否有相关权限

## Ruby 使用module 来打包一系列函数


## cookies 一个rake中间件
由Rails 内置的一个对象，可以看成为Hash，每个element 的格式为
每次requiset 都会生成一个新的cookies对象
{value: xxx, expires: xxx}
value 是文本值
expires 是失效时间
#在view 和helper中访问cookies
  class MyController < ActionController::Base
     helper_method :cookies

cookies[:list_mode] = "xxxx"
cookies[:list_mode] = {value:'xxx', :expires => 5.minutes.from_new}
cookies.delete :key

存放一个签名数据
cookies.signed[:xxx] =value

通过cookies.permanent[:xxx] 来设置的value 自动有20年的有效期
    cookies.permanet.sigend[:key] 会加密对应的value,但是名字还是能被看见

在cookies中存放一个加密数据
cookies.encrypted[:xxx] =45

## session
一个hash 数据结构，Rails内建了session变量
rails为每一个页面创建一个session变量
session被存放在cookies中
使用一个32-len string作为id
档一个session创建后，server端会自动在发往client的cookie中填入这个session的id
session中只应该存放简单的string或这数字
session的存储方式
  配置文件
   config/initializers/session_store.rb << EOF
                config.session_store :active_record_store
		EOF
1. cookies, 默认有4k limit 现在，并且能被用户看到
2. 使用active record
   1. rake db:sessions:create
   2. config.session_store :active_record_store
3. 使用memcache
   2. config.session_store :active_record_store

session hash算法 
session_options[:digest] = 默认是SHA1, 也可以是OpenSSL支持的其他算法


清除session
    reset_session

### cookies 和 seesion的异同
cookies 是HTTP提供的机制,在每次请求头中传递信息. 都是明文.用户可以修改,有大小限制,不能存储敏感信息
seesion seesion 用来实现应用层的回话机制,Rails默认把session中的数据加密后,存放在客户端 
   一般只把id存放发送给client,这样就能够记录谁是谁, 每次都检测客户端发了的seesion_id

## asset pipeline
# 所有的资源都需要在清单文件中列出,才能进入Pipeline的处理流程
# 作用预编译,把不同资源文件压缩成一个文件,加快网页的加载速度
#
#* 清单文件
#
# 查看当前的assets 搜索路径, 默认有三处app/assets lib/assets, vonder/assets
#  所有在这三个目录下的子目录会自动被Rails查找
#
# * Rails.application.config.assets.paths
# * 添加查找目录
#
# 每个controller 都有一个对应的js 和 css 文件
# 在这些文件里面写入以后,必须在application.js/css 中 =require 对应的文件才能使用
#
# 引入一个包以后要加入js文件 安装pipeline的所搜路径指定需要的js文件的名字就好
# e.g. 引入 ace.js文件
# //= require ace-builds/src-min-noconflict/ace
#
#* 指令
#//=require_directory [路径] 将路径下，不包含子目录的文件按照字母顺序依次载入。
#//=require_tree [路径]  将路径下的文件，包含子文件夹中的js文件全部载入 
#//= require_self 是引用当前文件，一般是application

#* 编译指令
# rails assets:precompile
#
## 预编译在生成环境中使用,放在public/assets 目录下
# rake assets:precompile RAILS_ENV=production ## 主要需要指定production才能开启压缩代码
# 如果出现undefine method [] nil 错误, 把app/assets/style/下面所有的文件都改为.css.scss结尾
# 预编译的结果会放到 public/asset/下

#* 在view中引用pipeline资源
# 使用hepler image_tag "只要名字就可以不需要路径
# javascript_include_tag 
# stylesheet_link_tag

##image
#图片可以直接放入public文件夹,
# 然后直接在view 中img src="name.png" 就可以引用
#可以

## login
# 就是在cookies中添加一个id, 每次前端都传递这个id给后端,后端通过查找id,来确定
# 当然这个id应该签名,或加密才对
* 实现机制
  把session 作为一个resource, 上线就是create session
     线下就是destory session
  使用cooke 存储
   Session 的作用， 有model 吗?

   1. 创建session Server端给client 生成一个seesion_token
   2. Client 把seesion_token 存到cooke 中，
   3. 每次发送请求，连带发送cooke 中的session_token 
   4. Server 每次处理Request 时，先比较seesion_token 是否正确
         如何比较???

   Rails 内建了一个session 变量
   e.g. user
        user_session

     每个session中都有一个 session[:session_id]
     在 user model 中添加一个session_id 自动
      每次用户上线后就
      session[:user_id] = 


* 密码验证
* 访问控制 实现
   当用户登录时，创建session
      sessin里存放当前的 user_id
      e.g. 
      session[:seller_id] = @seller.id

      logout 就是删除对应的session
  def logout
    session[:seller_id] = nil
    redirect_to login_new_path, notice: 'Logout successfully'

  end

  def user_authenticate
    if user_loggedin? 
      Rails.logger.debug("authentication_ is user_loggedin #{@current_user.id}")
    else
	    ## 传递一个当前页面的url给登录页面，作为登录后的跳转页面
      redirect_to login_users_path(return_url: request.original_url), notice: '请登录系统'
    end
  end

    写一个authenticate -> bool 的函数用来做登录认证
    实现 current_user fn 返回一个User的obj

def current_user
 return unless session[:user_id]
 @current_user ||= User.find(session[:user_id])
end

def logged_in?
  current_user.is_a? User
end

def authenticate
  logged_in? || redirect_to login_path
end


     

* 安全措施
  避免会话劫持，只能全站开启SSL
  因为登陆的remember_token 也记录在cookies 中


## rails app starup
1. config/boot.rb sets up Bundler and load path
2. application.rb loads gems
3. environment.rb runs all initializers


## Erb
<%和<%=不太一樣，前者只執行不輸出，
像用來迭代的each和end這兩行就不需要輸出。而後者<%= 裡的結果會輸出給瀏覽器。

## Module 在Rails 中一个module 会自动的映射到一个数据库table, table
  的名字就是module 的class 的名字复数

## create new app
rails new <AppName>

## config

## Time
Time Rails 默认的时间格式为UTC 时区是00
DB中存储的也是UTC时间
显示的也是
如何想默认按当前时区显示，则可以设置　config.time_zone='Beijing'
如果想在DB中以当前时区存储则　config.active_record.default_timezone = :local

  config/databse.yml 来配置DB的
  Time zero
  config/application.rb config.time_zone= ?


运行 rake time:zones:all OFFSET=+8
显示所有+8时区
在db中还是存的UTC时间

不要用time.now 这个时间是根据系统当前时间
使用time.zone.now
一个tiemobj.localtime 显示当前时区时间

## 格式化

puts time.to_s
puts time.ctime
puts time.localtime
puts time.strftime("%Y-%m-%d %H:%M:%S")

to_s 默认是to_s(:default)
还可以指定　　to_s(:db)
如何想全局自定义　则可以设置　Time::DATE_FORMATS 中的key 来设置
在　init 文件中

my_datetime_formats = { :default => "%Y-%m-%d %H:%M:%S" } 
my_date_formats = { :default => '%Y-%m-%d' } 
Time::DATE_FORMATS.merge!(my_datetime_formats)
Date::DATE_FORMATS.merge!(my_date_formats)

当然也可以定义其他key 然后在to_s中指定参数

Time/Date的DATE_FORMATS 有很多内置格式
Time::DATE_FORMATS.keys

输出UNIX时间戳
to_s :number
to_s 



## 18n 国际化
#  和android 相同，给每个字符串对应不同的local定义值/ config/locales/xx.yml
#  在其他地方使用I18n.t ('stirngKey') 
#  在 view 中使用 t('stringKey') 来引用value
#
#  代码以的标签都是英文，
#  每一个语言都有一个local文件，把这些文字翻译为对应语言
#
#  local文件 Rails 会自动加载config/locales/下面的所有.rb .yml文件
#  添加加载路径　config.i18n.load_path += Dir[Rails.root.join('my','locales', '*.{rb,yml}'.to_s]
#
#  设置默认语言
#    config.i18n.default_locale = :zh
#  

## trun on cache response
 config/environments/development.rb
  config.action_controller.perform_caching = true

## rake log:clear
#    

### 生成脚手架
  rails generate scaffold TableName<单数形式> FieldName:Type FieldName2:Type2

  如果已经生成了scaffold 但是有给model 添加了新的字段
  可以再次使用scaffold --skip-migration 来给view 添加新的fields

   这会生成 app/models/TableName.rb
            app/views/TableName/...
            app/controllers/TableName_controller.rb
               ......
            db/migrate/Timesteam_create_TableName.rb

使用 rake 命令来应用migration
  rake -T 查看所有选项

      e.g. rake db:migrate
             这个命令会应用所有还没有被应用migrateions to database

            ake db:rollback
	    rake db:migrate:status

Migration 搭配的 Rake 任務

    rake db:create 依照目前的 RAILS_ENV 環境建立資料庫, 创建db
    rake db:create:all 建立所有環境的資料庫
    rake db:drop 依照目前的 RAILS_ENV 環境刪除資料庫
    rake db:drop:all 刪除所有環境的資料庫
    rake db:migrate 執行Migration動作
    rake db:migrate:reset 用了清除　NO FILE 问题
    rake db:migrate:up VERSION=20080906120000 執行特定版本的Migration
    rake db:migrate:down VERSION=20080906120000 回復特定版本的Migration
    rake db:rollback STEP=n 回復上N個 Migration 動作
    rake db:version 目前資料庫的Migration版本
    rake db:seed 執行 db/seeds.rb 載入種子資料

* 如果执行失败可以是使用　
  rails destroy scaffold <Name> 撤销操作

##EE model ActiveRecord
#使用不同的DB， 兼容性不是很好，所以在测试的时候就使用和生产环境一样的DB
*ActiveRecord 类是对一个表中一个row的表示，并不是对DB table 的表示
*ActiveRecord 并不定义对应的表中的属性（字段)是因为，运行是，对自动的分析
   DB表的每个字段
* 一个ActiveRecord 对应的表，是根据这个类的名字来查找的，可以使用
   self.table_name "tableName" 来指定对应的表


EE 单表继承
 一个或多个Model继承于另一个Model,并且最终它们用的是同一张表
class Company < ActiveRecord::Base; 
end
class Firm < Company; end
class Client < Company; end
ActiveRecord 可以继承，但是所有相关类的实例都会写在一个表中

通过在表中添加名字来区别不同的类型.
* 必须在表中添加type : string,来触发单表继承,没有则不会
* 使用继承的类型create的时候会自动填写 type
* 不同的module 不一定要对应到不同的DB表

EE 多态关联
  Polymorphic = true
  意思是，belongs_to 多个不同的类型，这些类型在逻辑上是一个东西,
  每个对象只能关联到这些类型中的一个类型


rails 会自动添加id 字段作为primary-key
run 'rails g model' 查看选项 

#### DB预加载
三种方法, includes, preload, eager_load


config.eager_load  时候开启lazey 加载

* N+1 使用includes
users = User.includes(:address).limit(10)
筛选includes的select, 不可以,但是可以通过scope来简介完成
e.g.
~~~ruby
  belongs_to :teacher,-> {select(:id, :name)},  foreign_key: :owner_id
~~~
  


继承后， className 和db tableName 之间对应为单数-> 多数. Book -> books
可以显示设置
 class Book < ActiveRecord::Base
   self.table_name = "xxx"
   self.primary_key= "_id"

   def name 
     read_attribute(:name) || 'n/a'
   end # 没有数据时返回 'n/a'

   def name=(n)
     write_attribute(:name, n + '.com') 
   end 

   ## 等价的可以这样写
   def title
     self[:title] || 'n/a'
   end

   def title=(t)
     self[:title] = t + ' .com' 
   end
 end

config
   可以在application.rb 中设置全局配置
   primary_key_prefix_type
   table_name_prefix
   table_name_suffix
    
模型层的属性设置
  并不使用实例变量， 通过read_attribute, write_attribute 来设置
e.g.


生成model 后,并没有产生db table, 这时可以修改参数, 直到调用 db:migrate 后
 才会生成db table

  有一个可选的hash 
      #add_reference(:products, :supplier, index: { unique: true })



  unique index add to Model file
  add_index(:<tableName>, [:bar_code], unique: true) //注意这个函数是DB级别的现在
                并且需要写在 migrate文件中，而不是Model.rb 文件中定义


## Database db
#
* console 连不上DB
ActiveRecord::Base.connection

# database 都在 config/databse.yml 中配置
#  Rails 在不同环境中使用不同的 DB, 如 development, test, produce
#  使用ORM 模型
#  每个module 就是一个table
#  
#    每个colum 就是一个对象的属性
#  Active Record, 就是一个row

# 添加db 测试数据
# Gem faker
 
# 分页get, 分页显示 ???
# Module API 如何支持分页拉去
# 
# Gems
# 
# 写自己的gem
# rails g plugin <Name>
# 
#   will_paginate
#     对所有module 都添加了　.paginate 方法
#     需要把controller 中的index Action 中的.all 方法换成
#     .paginate
#     e.g. @users = User.all
#          @users = User.paginate(:page => params[:page], :per_page => 20)
#     
#     在view 中如果需用显示分页连接需要加入 <%= will_paginate @users %>
#     Qus. page 的总数量等如何在view 中取得??
#     
#   bootstrap-will_paginate
#   
# Ajax 如何请求???
# 
#

## scope
#   有一个defualt_scope 是只要定义会回自动调用的
#   
#   Named Scope
#  可以自定义ActiveRecord 导出func
#  scope :recent, lambad {order('updated_at DESC')}
#  e.g. xx.recent eq xx.order('updated_at  DESC')}


# 多态关联
#  polymorphic: true

## callback
  around_save :list_to_json
  after_initialize :json_to_list

  # 存入json格式到DB, 但是obj持有ruby 原声格式list
  def list_to_json
    list  = signed_student
    self.signed_student = signed_student.to_json
    yield
    self.signed_student = list
  end

## 单表继承 inh
默认一个表可以集成另一个表, colument的参数是type
self.inheritance_column = nil #屏蔽单表继承,默认名字为type


Megirate
  
不想要id
create_table :name, id: false do |t|

该类型
create_table :name, id: :string do |t|
end

改变id名字
create_table(:objects, primary_key: 'guid') do |t|
end

t.column(:name, type, options={})
t.<type>(:name, option={}) 
   <type>:
    (string, text, integer, float, decimal, datetime, timestamp, time, date, binary, boolean).
  options:
   default
   limit
   null: false

t.index(:column, unique: true)
t.belongs_to 等价与 t.references
这里的belongs_to 和modle中的不同, 这里知识添加一个xxx_id 的东西
modle 中的belongs_to 会导出helper

rails给通用的类型定义了type,有对每个特殊db，定义了自己的type
可以查看 NATIVE_DATABASE_TYPES, 来查找类型映射

每个选项都有, null, default, limit 这三个可选参数

* 自定义主键
t.integer :id, primary_key:true, null:false, 不顶用
t.primary_key :id #不能使用, limit:8

* 不通过model 直接执行sql 语句
  s = ActiveRecord::Base.connection.execute("SELECT * from users")
  s.each(:as => hash) do | row |
    puts row
  end

mysql 可以这样制定主键的类型
  在最后重新设置:id 的类型
    change_column :users, :id, :integer, limit:8
    这样就去掉了auto_increment


t.primary_key :name # ok 但是类型为integer
 对于其他类型，需要
   t.string "otherId", null: false
   add_index "table", "otherId", unique:true


dump to DB TABLE struct SQL to file
rake db:structure:dump


* default all fields can be access
   if you want limit it. can be use attr_accessible FieldName
     e.g.  attr_accessible :name, :email

* defalut value
      t.integer :points :default => 0

      save file && rake db:migrate

references :xxx 等效于 integer :xxx_id 
 使用references并不会设定外键关系,如果要要显式设置
  注意是单数形式
   如果在脚手架设定 references 则会生成，对应的外键关系
     e.g.
      t.references :ware, index: true, foreign_key: true
   定义references table, 而不是 table_id , _id rails 会自动添加
   在创建这个对象时,必须给出references的值,否则会报错


  add_references/ add_belogs_to 和add_foreign_key 是一样的，最后都调用
  add_foreign_key
* add_foreign_key
    e.g. add_foreign_key :books, :users
     will add a'user_id' to books
    e.g. add_foreign_key :books, :users, name: :my_user
         add_foreign_key "courses", "users", column: "creator_id"

* 自定义名字
  add_reference(:courses, :creator, foreign_key: {to_table: :users}, index:true, null:false)


associations
--------------------------------
定义这些会让Ｒａｉｌｓ导出合适的ＡＰＩ，　
Ｒａｉｌｓ会自动生成合适的ＳＱＬ语言来查询对应的ｔａｂｌｅ

* belongs_to : <tableName>单数形式

  belongs_to :course, foreign_type: :temp_id # 使用指定的字段来查,默认为course_id
  belongs_to 会给row的创建添加约束,在创建row时,必须有belongs_to的对象存在
  如果是可选的使用 :optional :true


* has_many : 
   加这定义的作用?
     自动生成相关联系操作
     Rails 约定 外键的名字由 table + _id 构成
    e.g. aaa.xxxs get  aaa 的all xxx
          aaa has_many xxx(复数)
          xxx belongs_to aaa （单数)

   * xxx Model 本身需要有aaa_id 这个属性用来标记自己属于的aaa
  可选参数
  :class_name  默认关联的类型为XX, 如果类型不是使用class_name 指定
  :conditions 
  :primary_key 默认是另一张表的id 字段信息关联,如果不是使用primary_key 重写
  :foregin_key 默认是xxx_id 进行关联,如果字段名字不是,可以使用foregin_key
  :order  用了指定以xxxs 中的哪个字段来排序返回 e.g. -> {order('fieldName DESC')}
       也可以在指定一个二次排序field e.g. -> {order('fieldName DESC, xxxName ASC')}
       中的参数会附加在SQL 语句中，所以可以写任何DB支持的语句

  :dependent 
     如果要是删除Ａ是ａ的所有ｂ也要确保删除，就是用
     　　　dependent: :destroy
     如果要是删除Ａ是ａ的所有ｂ的a_id 变为NULL 则
     　　　dependent: :nullify

    

* has_one one-to-one parent
  对应的table里的要有本table 的TableName_id field
  约定的名字为 tableName + _id
  可选参数
  :class_name
  :conditions
  :foregin_key
  :order 
  :dependent

* belongs_to :one-to-one/has_many 
     child table 中填写

many_to_many
------------------------------------
  比如数,和种类标签, 类似豆瓣
   一本书可以有多个标签, 一种标签也可以有多本书
   有两种

1. has_and_belongs_to_many 
   使用一个join table 来实现
    has_and_belongs_to_many gives you a simple lookup table which references your two models.
    注意join table 只是一个db table 不是 ActiveModel
    比has_many :through 简单,但是很多实际的问题并不能解决

     has_and_belongs_to_many :students, join_table: :courses_register_students

     e.g.
       class CreateArticlesCategories < ActiveRecord::Migration
         def change
           create_table :articles_categories, :id => false do |t|
             t.references :article
             t.references :category
           end
         end
         def self.down
           drop_table :articles_categories
         end
     end

     如何添加关系(给join_table 中添加数据)
      <<
      user = User.find(params[:id])
      promotion = Promotion.find(params[:promo_id])
      user.promotions << promotion

      删除
      user.promotions.delelte(promotion_id)
   

2. has_many :through
     一般用来多对多
     通关一个中间Modle 来连接两个Model
      比如 a has_many b, b belongs_to c, b belongs_to a
      则 a has_many c :though b
      e.g.
  has_many :replies, :through => :books, :source => :comments

  has_many :students, :foreign_key => :ban_id, :primary_key => :id #另一个表的查询自动
 在students.ban_id 中选择和本表:ban_id 字段一样的row，
       

delegate: :method1, method2, to :moduleName
  代理制定的方法

还可以指定是否带有前缀，用于解决冲突
* prefix
delegate: :method1, method2, to :moduleName, prefix: true
 这样产生的代理方法，必须加上 moduleName_

* allow_nil: boolean()
   如果是true， 当代理mehtod为nil时，返回nil, 否则raise NoMethodError
   
      
  
一个module 可以对应多个views,

* before_save
  e.g. before_save {|user| user.email = email.downcase}

markdown:
"<h3>xxx</h3>.html_safe"
html_safe 把一个字符串作为模板的本身

## JSON
# 使用ruby 的JSON.prase 可能会保存
# 使用 ActiveSupport::JSON.decode(signed_student)

find
---------------------------------------
* where 条件查找
  Model.where(Field => matchValue)
  where 可以接收纯 SQL语句
   where('created_at <= ?', Time.now) 
   会直接使用SQL 的where 拼接参数
   where('created_at <= ? AND name= ?', Time.now, 'fff') 
   where('created_at between ? AND ?', start, last)
   where 的参数格式不能混用


 
Scope
--------------------------------------------
默认scope 在任何查询中都会自动添加
  e.g. default_scope lambda {order('categories.name')}
    #   User.order('name DESC')
    

具名scope
 e.g. scope :Name, lambda { xxxx }
 然后就可以使用Model.scopeName 调用
    类似一个过滤器, 可以在call chain  中使用


seeds.rb
----------------
这个文件中定义app 总是需要的数据
load seed 'rake db:seed
在这个文件里面 填写需要的数据


如果有更改 seed 使用 db:setup


## error report
obj.save 后如果返回false，
obj.errors[:各个属性] 可以得到这个属性是否有错误
obj.errors.any?
obj.errors.full_messages 有所有错误string组成的[string()]

obj.new_record?
 用了测试obj 以前是否调用过save


obj.attributes


## modify fields
1. create a migrate file
2. type your modifty code
3. run rake db:migrate

Or 
1. run rails g migration FileName option
## add fields
e.g. rails g migrate add_FieldName_to_ModleName FieldName : Type

## delete migration file
rails destroy migration <FileName>

## delete column
## add column 
#.e.g
class UsersRemovePassword < ActiveRecord::Migration
  def change
      remove_column :users, :password
      add_column :users, :password_digest, :string
      #t.column :password_digest, :string
  end
end


## 验证active fields 的有效性, 
#  check when obj.save(), not obj.new()
#  有两种格式，长格式和短格式
#  validates_absence_of :name 长格式　＝＝　validates :name, absence: {xxx}

    validates :title, :description, :image_url, presence: true

    + validates(Hash)  check one or  more model fields is not nil
    + presence: true will check echo fieleds is present. and its contents are not empty.

    + validates_absence_of 验证一个字段必须是blank?的
 
    + 唯一性
       uniqueness: true
        e.g. validates :title, uniqueness: true

    + 满足特点格式,math模式 URL or Mail
        validates_format_of :email, options{}
        e.g.
          validates :image_url, allow_blank: true, format: {
             with: %r{\.(gif|jpg|png)\Z}i, 
             message: 'must be a URL ofr GIF, JPG or PNG image.'
          }

    + 长度
         e.g.    
	validates :password, length: {minimum: 6}
           length: {maximum: xxxx}
        length 的验证可以用于integer类型的属性上，会对该属性to_s 在检length


    + 检测一个参数值包含数值
        e.g. validates :price, numericality: {greater_than_or_equal_to: 0.1}
        e.g. validates_numericality_of :xx_id, only_integer: true
	 可选参数
	:equal_to
	:greater_than
	:greater_than_or_equal_to
	:less_than
	:less_than_or_equal_to
	:other_than
	

     + 在指定的范围内
       validates_inclusion_of :sex, in: %(male, famale), message: 'bad' #sex 必须是male 或者 famale
       inclusion: { in: 0..9 }
       #  范围在in 中制定


     + validates_with OtherClass 交给一个class来验证
        class OtherClass < ActiveRecord::Validator
          
        
        
  has_many :line_items, dependent: :destroy
      has_many, belond_to 
         dependent: :destroy is when delete item, Rails will auto delete has_many items
  使用has_many 就可以定义，不需要在modle 中显示写出来
     
     +   validates_confirmation_of :password 
	    会 产生一个<FeildName>_confirmation 的虚拟属性．在ｎｅｗ的时候必须有，而且内容要和password 相同
	     在view中需要填写对应的confirmation field
	      不一定是password 可以是任何fields e.g. #{fieldName}_configrmation

Rails load 所有的stylesheets at once

## add columns to a model
#   rails generate migration add_XXX_to_TABLE
#   e.g.
#     rails generate migration add_quantity_to_line_tiems quantity:integer



## view
Rails 使用laouts 来控制显示的布局.
  不同的page 都可以共享相同的layouts
* If you layout to a specific controller, you can create a file that name with 
    the contorller name e.g. AAs.html.haml
    + 也可以在 contorller Class 中使用 layout method 指定
      e.g. Class XX < ApplicationContorller
                layout 'LaoutName'
    + 在render 时也可以expilcit without layout   e.g. render :layout => false;
    + 如果有一个和ControllName一样的layout文件,则默认的application Layout就不会在加载了

* Rails 根据controller class 的继承关系来寻找match 的 layout

如果局部视图要在多个controller 中公用则需要放在
app/view/shared/  以_ 开头 ,render 中则去掉_
   e.g. _error_messages <%= render error_message %>

render 渲染
--------------------------------
每个action 有默认的render
  如果不要render, 可以指定跳转到另一个页面(使用redirect)

render partial: 'room', locals: {nick: @nick}

   render :type , options
   所有的 render 的模板都是在view 根目录下的
   可以向 render 传递变量
    e.g. render 'form', :title = > 'jfoeif'

    render(:text => string)  
    直接渲染出文本, rails default content_type: text/html,
     you can render(:text 'hello', content_type: 'text/plain')


    render(:inline => string, [:type => "rhtml"|"rxml"])   
       传入的string渲染成模板（rhtml或者rxml）
    render(:action => action_name)   
      直接调用某个action的模板，相当于forward到一个view
    render()   
      默认的的render, 相当于render(:action => self) 

    render(:file => path, [:use_full_path => true|false])  
     使用某个模板文件render, 当use_full_path参数为true时可以传入相对路径

    render(:template => name)  
     使用模板名render，e.x.: render(:template => "blog/short_list")

    render(:partial => name, locals:{xx: xx})  
      以局部模板渲染 没有歧义的情况下，是不需要指定 partial

    render(:nothing=>true)  

   render @Name 的意思是　调用view 中名为Name.class 的模板 _Name.html.xxx 的视图

      如果 是复数 render @books
        则Rails 会自动for_each books 中的每一个book, 调用 _book.html.xx
      渲染一个模板 Names 中的每个对象
        == @books.each do |book|
	     render book
	   end

     render :inline '<%= fef{xxxx} %>'  render

     render nothing
        use :head :http_code equie as render nothing: true, status 401
     
     可选的 options:
         :content_type
	 :layout
	 :status

* redirect_to 
    让浏览器跳转到指定页面
      e.g. redirect_to xxx_path
       redirect_to @xxx 也可以接收一个obj 意思书跳转到这个obj 的show 页面
          等价于 redirect_to(xxx_path(:id=> @xxx))

	可以是一个action 

   redirect_to :back # 掉回到上一页
   redirect_to obj, alert: "message" 在flash[alter] 中添加message
   redirect_to obj, notice: "message" 在flash[notice] 中添加message

   redirect_to "https://github.com/404.html" 可以直接重定向到一个网站页面


    n秒自动跳转
    <meta http-equiv="Refresh" content="2;URL=www.xx.com"/>


   Rails4 中可以注册新的flash 类型，这样就可以在redirect_to中使用注册的类型
	class ApplicationController
	...
	add_flash_types :error
	end



## Controller
#
#
  + generate controller
    generate 可以简写为 g 一般为复数形式

      rails generate controller Name Actions...
        会生成
         app/controllers/Name_controller.rb
         app/views/Name/....

 如何删除一个controller
   rails destroy controller ....

   +  generate controller 可以接收指定的action
       e.g. controller StaticPages home about help

   +  g scaffload_conteroller when mode already exists
  ## create 
   ## form submit
   # form 在create 函数中使用变量 params 包括了所有的提交的参数
   #  e..g
  def create
    render text: params.inspect ## 把params 装换成string 打印出来
    render text: params[:posts].inspect ## 把params 中的指定form 装换成string 打印出来
    #用在view 中访问create 中的变量
    #必须定义成类实例变量
    @posts = params[:posts]
  end

   在提交以后 

      redirect_to @post ## 直接跳转post_url() 所在的地址 会告诉client 发送GET请求

    所有咋
    * 打印render text: params.inspect


## view helper
#内置
form_tag 没有model实例
= form_tag '/rooms'  do
  = text_field_tag :nick
  = submit_tag "Enter Room"
form_for 有model实例


 让在 controller 中定义的方法 view 中调用
* helper_method [:current_user, :logged_in?]
  任何一个controller 的helper_method都可以在任何的view中调用

* 在view 中可以调用在helper中定义的任何函数，和这些函数定义的instance-obj
   controller 不能看见在helper 中定义单函数
   helper 也看不见controller 中定义的任何对象

   但是include 后就可在controller 中使用


## respond_to
根据不同的客户端请求，来相应不同类型的数据
通过request 中的元信息来发现请求的类型, Accept-Type
e.g.
 Action ...
   必须要有变量
 respond_to do |format|
      format.html # do nothing, allow Rails to render index.rhtml
      format.js # do nothing, allow Rails to render index.rjs
      format.xml { renderml => @airports.to_xml }
    end 


* before_action 
 在执行action 之前调用一些函数, 会内联到每个action 里面
  e.g. before_action  :set_member, only: [:show, :edit, :update, :destroy]
       before_action  :xxx        ,except :[:create]

       如果想要给调用的方法穿参，择可以
       before_action only:[:show, :edit] do
         xxx(3)
       end

     
Form set other attr
    <%= f.text_field :name %>
    <%= f.text_field :name , class: 'xxxx'%>
    <%= f.text_field :name , 'other-attr' -> 'xxxx'%>

     Or 
	class ActionView::Helpers::FormBuilder
	 def inputbox_field(method, options = {})
	text_field(method, options.merge(class: 'inputbox'))
						 end
						    end

* check_box_tag(Name, Value, Checked=bool(), options={})
  

## 有多种形式的select
* f.select :person_id, Person.all.collect { |p| [ p.name, p.id ] }, include_blank: true %>
* f.collection_select :college_id, College.all, :id, :name
                      这里college_id 必须设置了belongs_to college
		      :id 是设置存储的信息, 也是select 的value
		      :name 设置显示的信息
  select 有两个可选参数，第一个是这是选项信息的，第二个是这是html的
  添加class: 
      = f.select :ban_id, Ban.ids, {}, class: 'form-control'


## rounter
* 显示当前所有路由
#访问 http://localhost:3000/rails/info/routes 


#作用 把http的请求映射到controller active 上， 自动生产help方法
* rake routes 显示所有的路由路径
* 在view 中得到当前的route

* mount
    路由到自己的应用中
   mount AdminApp, at: '/admin'

* 设定一个root, root 'store#index', as: 'store'
    as 是定义对应的helper

* resources :products, param: :sku 把默认的:id 改为:sku

* resources :logic_nodes, :only => [:index, :show] 
　　　　　only 用了控制自动生成的helper

* member
   为Restful 添加新的action
   e.g. resources aa do
	  :member do 
	   get :bar
          end
      会生成 /aa/:id/bar

* collection
   和member类型也是添加一个新action 不过这个action对应与整个资源

   e.g. resources aa do
           collection do
             get 'search'
           get 'login', on :collection # 也是相同
           end
      会生成 /aa/search

  resources :ware_categories
    资源命名，一般约定为复数(Rails 机制上并不需要，随便写什么都行)，
    对应的controll class 也应时复数形式，
    映射路径根据 resources 指定的值相同， 不会做任何改变。 映射为的controller
    为resources 的值也相同，就是形式不同， _ 去掉， 小写变大写
     e.g. ware_categories -> WareCategories


  as: 'stroe' 会告诉Rails 创建一个 store_path 得访问方法.
  e.g. get '/teams/search/:query' => 'test#acefef', as: => 'search'
     就可以使用 search_url search_path
   
  * resources :posts
   一个 resources 会自动为这个资源生成符合　ＲＥＳＴ的路由

  定义模式 get ':Controller(/:Action(/:id(.:format)))'
      e.g. get '/test/search/:query' => 'test#action'
    * 括号的意思是，可选参数
    * 每个segment 都是一个参数使用:开头使用/ 分割， 在controller中可以使用
        params[:<SegmentName>] 获得h e.g. params[:id]
        http://test/search/?fjeofj:323?foef:3 
        url ? 后的参数也在params 中
        url 前些参数的时候使用helper_path(:key:value)
	    参数会赋值给:query 变量
	    变量以:开头
    * format 制定返回的格式, 在写rount的时候不需要写出来，Rails会默认所有的都有
              .e.g aici.books/show/1.json
       respond_to 会返回json格式， 如果没有匹配的格式Rails 会返回406
 
      至于匹配哪个格式，是根据format如果有的话，如果没有则根据HTTP
      协议中的Content-Type
    respond_to do |f|
      f.html {render text: 'html'}
      f.json{render text: 'json'}
      f.any {render json: xx} any 匹配Rails支持的其他所有format
    end

     
      f.html {render html: xx}
      f.json{render json: xx}

通过match 定义的需要制定 HTTP method， 使用via
match 'path', to: 'c#a', via: :get
match 'path', to: 'c#a', via: [:get, :post]
match 'path', to: 'c#a', via: :all

可以给路由中的变量添加验证
  get 'ookk/:id' => show, id: /\d+/  #==# 
  get 'ookk/:id' => show, constraints: {id: /\d+/}
       constraints: proc{|req| req.params[:id].to_id < 100} # 还可以是block
       constraints: {subdomain: 'api'}


## subdomain
#/etc/host 首先需要添加子域名
#e.g. 
# 127.0.0.1 api.localhost
# 127.0.0.1 *.localhost

#  如果request.subdome 是空 develement.rb 中添加
config.action_dispatch.tld_length = 0  ## 用来设置子域名从第几个.开始
www.aa.bb.com =0 的情况先
 subdomain = www.aa.bb =0
 subdomain = www.aa =1
 subdomain = www =2

error
* uninitialized constant 错误都是controll的文件名和resources的不匹配, 单复数问题



cookies 共享 需要设置：

自定义
lib/subdomain.rb << EOF
	class Subdomain
	  def self.matches?(request)

	    request.domain.split('.').size>1 && request.subdomain != "www"
	  end
	end

	constraints(Subdomain) do
	  get '/',  to: "custom#home", as: 'custom_root'
	end
EOF


  get 'ookk/:id' => show_error, id: /\d+/

 root 'welcome#index' # root 值接受get 请求

* nested resources
   resources AA do
      resources BB
   end
     一般是BB 在逻辑上附属于ＡＡ的，不肯能单独出现的
      比如一个帖子的评论，

   会自动生成nested named routes
    e.g.
      GET POST             AA_BBs_path
      GET PUT/PATCH DELETE AA_BB_path
      GET                  edit_AA_BB_path
      GET                  new_AA_BB_path

    在 view edit 需要传入AA, BB 来告诉
    Rails AA， BB 第嵌套关系
      e.g.  form_for([@aa, @aa.bbs.new]) do |f|
       等价于 form_for (:bb, @aa.bbs.new, url: [@aa, @aa.bbs.new])
        OR    form_for (:bb, @aa.bbs.new, url: aa_bbs_path(aa_id: @aa))


     = form_for([@user, @profile], url: user_profile_path) do |f|

  嵌套子资源的表达，必须传递，父资源和本资源
  e.g. 
  = form_for [@current_seller, @produce] do |f|

  而且不光是form_for 对于子资源的helper函数也要传入两个obj
   = link_to 'Edit', edit_seller_produce_path(@current_seller, @produce)

  [@aa, @bb] eq  aa_bb_path(:aa=> @aa, :id = > @bb)

+ shallow
   R4 之后增加的
  resources :products do
    resources :comment, shallow: true
  end

* Namespace routing
  当在routes 中有namespace :api do

  namespace :api, defaults: { format: :json },  ## 指定默认MIME 类型为json, 默认返回的类型为json, 也就是使用json模板渲染
                  constraints: { subdomain: 'api' }, ## 指定子域名api.xxx.com
		  path: '/'   ## 指定每个请求都是从/开始 ??
		  do
    scope module: :v1,  ## 需要建立api/v1 
      constraints: ApiConstraints.new(version: 1, default: true) do
      # We are going to list our resources here
      resources :users, :only => [:show, :create, :update, :destroy] ##api.xx.com/v1/user/:id
    end
  end


  的时候，Rails会自动的把这个namespace 对应到controller 同名的目录下
  Namespace controller
    rails g controller api/Name
      e.g. rails g controller admin/user
       
       不同的namespace 下可以有相同的controller

      namespace :admin do
        resources :users
      end

    
      admin_users
      edit_admin_user
      new_admin_user
   作用,用于组织一系列逻辑上相关的controller
    生成的rount path_hapler 和嵌套的资源相同

重定向
  get "/foo" , to: redirect('/moo') 


* 非RESTfull 路由形式
* RESTfull 路由形式
     e.g.
    posts GET    /posts(.:format)          posts#index
          POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post GET    /posts/:id(.:format)      posts#show
          PATCH  /posts/:id(.:format)      posts#update
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
GET
 link_to("Index", users_path)
 link_to("Show", user_path(Id))
 link_to("New", new_user_path)
 link_to("Edit", edit_user_path(Id))

  
 link_to 的path 参数可以是一个hash obj, path helper会根据key,
         来取得hash-obj 对应key的值

 link_to 'new lesson', lessons_path(:ban_course_id => @bc.id), :method => :post

helper path 是可以传参的
e.g. new_user_path(:id => 32)
   user?id=32


POST
  form_for @user, :url => users_path, :html => {:method => :post}

给 form_for 添加params
form_for @user :url => {:type=>3}
 生成 users/?type=3

 也可以使用 hidden fields 传递参数
 f.hidden_field
 hidden_field_tag
    
PUT
 form_for @user, :url => post_path(@user), :html => {:method => :put}


DELETE
 link_to("Delete", post_path(@user), :method => :delet)

resources :xxx
  复数形式
resource :xxx
  单数形式没有 index action 所有的URL-helper 也都是单数的
 不管是单数还是复数， 生成的controller Class都是复数形式
 不过可以 使用controller 指定
  resource :dashboard, controller: 'dashboard' 指定为点数

指定 controller
　默认和resources 同名
     e.g. resources :Name, :contoller => "xxxx"

* 限制动词通过　:except => [xx,xx]
      :only => :create
        可以指定action

* 具名路由
  可以自动生成具名辅助方法，
   + xxs_path, 
   + xxs_url
    RESTfull 形式的资源
   + xx_path(Id) /xx/:id
   + new_xx_path(Id)
   + edit_xx_path(Id)
　　会自动产生具名路由，但是非RESTfull 形式的，则必须手动定义(使用　match)
   e.g.
     get 'static_pages/help' -> get '/help' to: 'static_pages#help'
   e.g. 
     root 'static_pages#home' -> root to: 'static_pages#home'

* set other name with rount
  get '/signup', to: 'users#new' == 
  get '/signup' => 'users#new'

* segment key 的约束
  get ':controller/show/:id' => :show, constraints: {:id => /\d+/}
  get ':controller/show/:id' => :show_error
  get ':books/:id' => "xx#yy", constraints: proc {|req| req.params[:id]}

 可以在segment key中使用通配符 
  get 'books/*others' => "xx#yy"

* scope rount
   主要的避免重复
   get 'auctions/new' => 'auctions#new'
   get 'auctions/edit/:id' => 'auctions#edit'
   post 'auctions/pause/:id' => 'auctions#pause'

   scope controller: :auctions do
   get 'auctions/new' => :new
   get 'auctions/edit/:id' => :edit
   post 'auctions/pause/:id' => :pause
   end

   scope path: '/auctions', controller: :auctions do
   get 'new' => :new
   get 'edit/:id' => :edit
   post 'pause/:id' => :pause
   end

 给helper 添加前缀
   scope as: user do
   end


## traceroute
# 一个工具用来检测是否所有的action 与route 一一对应



Flash 是一个中间件用于在两个acton直接传递消息
---------------------------------------------
通常是一个acton　set, 写一个action get
当以在本action render 时就要使用可以使用 flash.now[:notice] ="feff"

flash 是 session 的应用，通常在 controller 的 action 间传递信息，读取成功后自动清空。
如果一个 flash 没有在合适得地方读出来，那么它将被保存到读出为止
flash 是一个hash, 通常使用flash[:notice] , flash[:alert]

在redirect_to 中可以默认设置 notice, alert
redirect_to :xx,  notice:'xxxxx'

flash的访问 hash形式,函数形式
flash/ flash.notice/flash.alert
flash 中的数据在下一会action显示后就会被清空

flash.now.notice
   如果不使用redirect_to 而是在当前请求中显示 使用.now

如果要添加新的key

flash.keep(key =nil) 保持当前flash或指定的key在下一个action时有效
flash.discard(k = nil) 指定flash在当前action结束后删除

  #     <% if flash[:notice] %>
  #       <div class="notice"><%= flash[:notice] %></div>
  #     <% end %>

### error_message 机制
#


action
--------------------------------------
Action 中预定义的的变量和方法
* action_name
* headers
* params -> hash
* request
     request.env["HTTP_HOST"]

     request.original_url ,当前页面的url
     request.headers["Content-Type"] 可以获取头部信息
     request.host 
     request.host_with_port
     request.subdomain
     request.protocol # "http://"
     request.remote_host
* session
* redirect_to



cb
------------------------------------
可以在acton 前后执行指定的回调
都要知道那个对用的action use :only :except
* cd 可以从继承体系继承， 如果父类中有cb 则子类也要调用

* before_action
    一般用于验证

* after_action

* around_action

* skip_before_action

## web  server
* WEBrick
    性能不足，一般用于开发中, 有些功能欠缺
    不要使用有些HTTP的协议没有实现，比如html5 video

* thin 
   使用替代WEBrick 在开发中使用
   很方便，在Gemfile 中添加 
   gem 'thin'
   rails s 会自动使用thin

  thin start --servers 3 -e production
  开启三个进程
  thin -h  查看帮助
 

* unicorn
    ?????

* Puma 
    大家都推荐的生成环境 rails web server

form_for
 建立表单
 e.g.
   <%= form_for @event, :url => { :controller => 'events', :action => 'create' } do |f| %>
    <%= f.label :name, "Name" %>
    <%= f.text_field :name %>

    <%= f.label :description, "Description" %>
    <%= f.text_area :description %>
    <%= f.submit "Create" %>
<% end %>
   # 每个field 的html属性直接写在后面即可
   # e.g.
  .field
    = f.label :name
    = f.text_field :name, placeholder: '请填入产品名'
  :name 等都必须是event 中的属性

simple_format是一個內建的View Helper，
 它的作用是可以將換行字元\n置換成<br />，有基本的HTML換行效果。
  rails g simple_form:install --bootstrap
  然后就可以使用simple_form_for(@xxx, html:{class=<bootstrap-form-class>})


form_tag 用于没有对应obj 的form生成
      = form_tag search_path do
        = search_field_tag 'search', nil, :placeholder=>'Search'
        = submit_tag 'Search'  data=>{:confirm => 'Are you sure', :disable_with=>"正在发送", type=>"json"}
   disable_with 用来避免重复发送
  type => json 指定发送的数据为json格式

= form_tag course_stat_teacher_path(current_user), :method => :get
  label_tag 请选择日期:
  input type="text" class="datepicker" name="start"
  label_tag to
  input type="text" class="datepicker" name="end"
  = submit_tag "Submit"
   
   如何得到参数get 还是通过params


* dom_id 用在view 中
  e.g. dom_id(category)
      生成 dom_id  id='category_3'

   

REST
路径
 注意资源的单复数
 show_ , new_ edit_, update_ , destroy_ 
  + <资源名>_path(Instance) 需要参数

 <Resource>s_path 复数不需要参数
 
## application
layout application.html.erb

## 3-thrid
# 放在public 
# root is public
# public 是上线后client 唯一能够访问的地方

## View
#
        <%= link_to 'Home', stores_path %>
* link_to 创建一个超链接
    link_to(Name,Path[,Hash])
          第三个参数是可选的, 用于URL的指定参数
     e.g. link_to "SignUp", '#', class: 'signup'
    如果想指定一个连接的格式可以
     linke_to "xx", path_hapler(@obj, :json)

    link_to 'Back', :back #回退

    link_to "<span class='lyphicon glyphicon-plus'></span>".html_safe, sign_lesson_courses_path(@course, l)
    内嵌标签

     Rails 使用路由的名字来指定连接

可以指定HTTP 动词,通过 method:
参数可以在healer 中指定e.g student_path(max:333, min:111)

## layout
提供统一的布局默认在 views/layouts/application.html.erb
  <%= stylesheet_link_tag    "application", media: "all", "data-turbolinks-track" => true %>
   
  <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
  <%= csrf_meta_tags %>
  <%= yield %>

## 一个layout中可以有多个yield 但是只能有一个无名yield,剩下的必须是有名 yield

head
 = yield :head ##命名yield, 配合content_for 用


## content_for
 有参数的 yield :xx ##相当于占了个位置, 把后门在content_for :xx
                    ## 中的内容添加到这里,即时没有:xx 也不会抱错
 需要配合 content_for :xx do
              <%= xxx 实际内容 %>
	  end
   来使用;
这里的:xx 只是标签,并不是模板文件
  

controller 级别layout tempate
layout 是会被继承的
如果在一个controllClass 中使用了
 layout :xxx
 则会覆盖掉以前的layout

如果在views/layout 中定义一个和controller同名的layout文件,
则会自动使用该文件,

* 如果是希望多态的插入片段
  可以使用 render "filename"
   这里的filename 默认是在当前contrller/view/_filename

  如果是在layout 下面需要指明
  可以使用 render "layouts/filename"
    render :partial "layouts/filename" 形式的简写

## nested layout 嵌套layout
content_for?

## 内置可访问变量
#* assigns
* controller    <%= debug(controller.controller_name) %>
* cookies a hash variable
* flash show message only for the duration of the next request
  常用 flash[:notice]
       flash[:alert] 用于more serious nature
       flash.now 用于在当前页显示信息,而不是下一个页面

    div.flash
      - flash.each do |k, v|
        p id= "#{k}" = v
* logger
* params
* request 应之用于debug
* response应之用于debug
* session



## passwed  验证 4.1 以后有内置支持
# Use ActiveModel has_secure_password
#  1. model加入 has_secure_password, 
#  2. model 中必须有password_digest 字段
#  3  modle 中 validates_confirmation_of :password 
#  4. 提交时必须有: password & password_confirmation. 这两个字段, model中不需要有
#      new 的时候可以只有password, 
#      但是如果有password_confirmation 就要和password 的相同，否则save 会失败，返回false
#
#      
#   加上后 model 的instance 就会导出一个 authenticate 函数用于验证
#    e.g.
#     
  def create
    user = User.find_by_email(params[:email])
    if user && user.authenticate(params[:password])
      session[:user_id] = user.id
      redirect_to root_path
    else
      redirect_to login_path
    end
  end

  def update
  user = User.first
  user.password = 'new data'
  user.password_confirmation = 'new data'
  user.save!
  end

f.password_field :password
f.password_field :password_confirmation 

# gem 'bcrypt-ruby', '~> 3.0.0' # provied bcrypt hash func
   ~> 的意思是安装版本号>3.0.0 但小于3.1.0 的版本
  一般建议使用精确版本号，不容易发生错误
#~> 2.0.3 等同于 >= 2.0.3 并且 < 2.1
#~> 2.1 等同于 >= 2.1 并且 < 3.0

Gems
   

   


+ Cucumber
  一个流行的驱动开发(BDD)工具
  扩展名为 .feature

+ devise
  Devise为Rails程序提供了一套易用的用户认证方案，
  你可以使用这个Gem实现用户登录，注册，找回密码，
  账户锁定等账户相关的功能。

   流行的权限管理Gem
   uses
     * gem devise
     * bundle install
     * rails g devise:install
     * echo config.action_mailer.default_url_options = {:host => 'localhost:3000'} >> config/devlopment.rb
     * rails g devise:views
     * rails g devise User
     * devise_for :users >> rount.rb
     * rake db:migrate


     自动添加的helpers
     signUP new_user_registration_path
     Eidt Account edit_user_registration_path
     Login new_user_session_path
     Logout destroy_user_session_path :method => :delet

     判断是否login current_user.blank?
     当前登陆者 current_user



gem "devise", '3.2.4'
gem "devise-async", '0.9.0'
gem 'omniauth', "~> 1.1.3"
gem 'omniauth-google-oauth2'
gem 'omniauth-twitter'
gem 'omniauth-github'
gem 'paperclip' 文件上传处理
     要求安装有convert 程序，并且可以调用
     使用在再要存放图像的modele 里面使用

 使用到了file 程序

  EOF >> < config/development.rb
    Paperclip.options[:command_path] = '/usr/bin/' 
  EOF

  EOF >> < <Model.rb>
    ##image 是field 的名字 可以定义大小尺寸
  ## 必须要有 has_attached_file, iamge 是字段的名字
  has_attached_file :image, :styles => {:medium=> "400x600#", :small=> "300x300>"} 

 一旦加入后，table会多出
    t.string   "data_file_name"
    t.string   "data_content_type"
    t.integer  "data_file_size"
    t.datetime "data_updated_at"
  这四个field


  validates_attachment_content_type :image, :content_type => /\Aimage\/.*\Z/
  EOF

  add Model
  rails g paperclip <Model> <field_name>

  View
    = image_tag @recipe.image.url(:medium, class: 'recipe_image')
    = image_tag @pin.image.url(:medium)
     使用obj.xx.url 


upload
  必须设置为multipart/form-data
 <form enctype="multipart/form-data" >
   <input type="file">
   rfc 1896 制定的http上传文件个协议
   表单的每个field使用一个boundary参数制定的分隔符分割




gem coccon 
  Rails中view层的form多层嵌套功能。Cocoon的使用，可以在标准的Rails中单独使用
   也可以结合Formtastic或SimpleForm使用。
   echo //= require cocoon >> application.js

   Model
    has_many :tasks
    accepts_nested_attributes_for :tasks, :reject_if => :all_blank, :allow_destroy => true

   此Gem主要提供了两个辅助方法:
   link_to_add_association
   link_to_remove_association


gem 'masonry-rails', '~> 0.2.1'
   图片显示瀑布流模式
   通过css id .class 来控制

gem 'searchkick' 
   站内搜索
  依赖elasticsearch


gem 'active_merchant'
   在线支付

 
gem 的机制
---------------------------------------------------


## Redis
+ install 
 gem redis

+ connect
  create an initializer in config/initializers/redis.rb and add the following:
  $redis = Redis.new(:host => 'localhost', :port => 6379)

## controller asset
1. 移除require_tree .
2.
<%= stylesheet_link_tag "application", params[:controller], :media => "all" %>
<%= javascript_include_tag "application", params[:controller] %>

3. 加入pipeline
%w( controller_one controller_two controller_three ).each do |controller|
  Rails.application.config.assets.precompile += ["#{controller}.js.coffee", "#{controller}.css"]
end

## Rack
#类似与Make
#
#rack --tasks 查看所有任务
#
#在lib/tasks 中定义
#
namespace :my do #可以不要
  task :name do
  end
end

exec
rake my:name

## ActionController::Live
#  r4 内建的用于发送大数据的功能
#   e.g.
#   
#  用来实现SEE server-sent-event
# Streams about 180 MB of generated data to the browser.
include ActionController::Live
def stream
  10_000_000.times do |i|
  response.stream.write "This is line #{i}\n"
  end
ensure
  response.stream.close
end

注意事项;
All actions executed from ActionController::Live enabled controllers are run in a separate thread.
This means the controller action code being executed must be threadsafe.
• A concurrent Ruby web server, such as puma 5, is required to take advantage of live streaming.
• Headers must be added to the response before anything is written to the client.
• Streams must be closed once finished, otherwise a socket may be left open indefinitely.

## VIM rails快捷键
R 大头的
E 开头的用于创建

## MongoDB
#Rails 使用的驱动为
#driver mongoDB 官方提供
#gem 'mongo', '~> 2.0'
#
#ROM associations validations 相关功能
#gem 'mogoid', '~> 5.0.0'
#




## exception
* rescue_from 来在controller scope 中handle制定的异常
# 
  def log_exception(exception)
    application_trace = ActionDispatch::ExceptionWrapper.new(env, exception).application_trace
    application_trace.map!{ |t| "  #{t}\n" }
    logger.error "\n#{exception.class.name} (#{exception.message}):\n#{application_trace.join}"
  end

## RSS / ATOM
 auto_discovery_link_tag
 或者是 link_to "rss", xxx_path(format: "rss")
  在对应的action中提供rss 格式的数据

## UJS
#  rails 使用 unobtrusive js 技术
#  
  f.submit nil, :data => {"disable-with" => "请稍等..."}
  f.submit'Search'  data=>{:confirm => 'Are you sure', :disable_with=>"正在发送", type=>"json"}


## Gem mini-profiler
# 性能分析工具
# 


* Gem brakeman
  安全分析工具

* Gem rubyocop
  一个语法style 静态分析工具

##EE Gem browser
#浏览器类型发现


##EE Gem gollum-lib
#built ont git wiki system
#安装完后,还有根据所使用的文档类型,安装文档解析gem
# e.g. gem wikicloth

## icon identicon github style 
#  gem 'identicon'
#  使用 
  <%= image_tag(Identicon.data_url_for(@user.name, 128)) %>
  会自动生成内联的img data


  Identicon.file_for "User's email? Username? Telephone?", "/path/to/the/image"
  生成图片文件	

  background-image: url(edit_bk.png);

还有一种是使用纯前端的cavase 来生成图片

## API
#使用 active_model_serializers 在model　层得到json格式数据
gem 'active_model_serializers'  


##API URL
#两个gem 
* Rails-api
* Grape


#
#使用 --trace 查看详细信息
#配置命令 
#set :name,  'xxxx'
#task :taskName do # 定义task
#  end
#invoke :taskName 调用task
#
   
## XML
#Rails 4 中不支持直接对XML 格式body进行处理
#params[:xml][:elemName]
# 可以使用gem 来处理
# 1. gem 'actionpack-xml_parser'
# 2. 在　config/application.rb << EOF
#  require 'action_dispatch/xml_params_parser'
#
#   config.middleware.insert_after ActionDispatch::ParamsParser, ActionDispatch::XmlParamsParser
#  EOF


josnb
pg 支持
　　
1. t.jsonb :info,  null:false, default:{} # 注意默认值不能为'{}'
2. 若是想在obj中直接访问json中的数据, 可以使用
   store_accessor :info, :name, :oo
3. jsonb 默认都是字符串,symbol无法访问, 可以使用
  serialize :info, HashSerializer 这个会影响new操作!!! pg josnb 不需要这样
  何时调用???
def HashSerializer
  def self.dump(info)
    info.to_json
  end

  def self.load(info)
  (info || {}).with_indifferent_access ## ActiveSupport 的,key支持,string, symbol 两种不同类型,访问相同,都会转换为string
  end
end

single-table inheritance
单表继承
多个不同类型的modle公用一个db table
table中默认使用type 字段来存放每个row的类型
如果不小心使用了type字段可以使用,来避免冲突
self.inheritance_column = nil


## Rails appliaction 对象
#每个应用是一个Rails App 定义在config/initializer 中
#访问Rails.application 就是当前应用的obj 全局

### Mime
#通过文件扩展名查询对应 mime
Mime::EXTENSION_LOOKUP['.pdf']
Mime::Type.lookup_by_extension('c')


* 注册一个mime 把文件扩展名和mime关联起来, 可以在send_data的时候,自动填写所关联的Mime

respond_to do |fmt|
	fmt.html #执行默认动作渲染模板文件
	fmt.csv  { ... }
end
这里的类型使用
Mime::Type.register "text/csv", :csv 进行注册后才能识别

config/initializers/mime_types.rb << EOF
 Mime::Type.register "application/pdf", :pdf
EOF

 send_data(data, 'filename.pdf')


