## Rails
 是一个全栈的MVC web 框架
rails new <name>
rails new <name> --skip-bundle ## 加快速度

 rails 对ruby 的内置类进行了修改
 e.g. String add blank?

rails -s -b 0.0.0.0 绑定ip

production 模式
rails -e production 指定启动模式
需要 生成secret_key
  rake secret RAILS_ENV=production
  把生成的key export 到环境变量中,也可直接放在 config/secrets.yml中
  production:  
    secret_key_base: <%= ENV["SECRET_KEY_BASE"] %>  

background 后台运行Rails
-d 后台运行
1. nohup <cmd> &
   nohup rails s -e production
   pid 在/tmp/pids/server.pid

2.  rails s -d


## Qus.
 + CMS　系统
   comfortableMexicanSofa
   gem 'comfortable_mexican_sofa'
	Then from your Rails project's folder run these commands:
	bundle install
	rails generate comfy:cms
	rake db:migrate

 + 如何开启temple cache

 +  404

  def render_403
    head :forbidden
  end

  def render_404
    #render file: Rails.root.join("public", "404"), layout: false, status: "404"
    render :file => 'public/404.html', layout: false, status: "404"
  end


 + 一般写在ApplicationContorller 中
  def no_cache_headers
    response.headers["Cache-Control"] = "no-cache, no-store, max-age=0, must-revalidate"
    response.headers["Pragma"] = "no-cache"
    response.headers["Expires"] = "Fri, 01 Jan 1990 00:00:00 GMT"
  end

  def default_headers
    headers['X-Frame-Options'] = 'DENY'
    headers['X-XSS-Protection'] = '1; mode=block'
    headers['X-UA-Compatible'] = 'IE=edge'
    headers['X-Content-Type-Options'] = 'nosniff'
    # Enabling HSTS for non-standard ports would send clients to the wrong port
    if Gitlab.config.gitlab.https and Gitlab.config.gitlab.port == 443
      headers['Strict-Transport-Security'] = 'max-age=31536000'
    end
  end

 + rescue_for类型与missing_method
    用于处理制定的异常，回调
	FooController < ActionController::Base
	  rescue_from ActiveRecord::RecordNotFound, with: not_found

	  private
	  def notfound
	    message = "Foo with ID #{params[:id]} not found."
	    logger.error message
	    redirect_to not_found_url, info: message
	  end
	end
    
     党在 FooController scope 里面生成一个RecordNotFound 异常后，
     就会调用 not_found

      ## 也可以直接写block
     rescue_from ActiveRecord::RecordNotFound do |exception|
	     message = "Foo with ID #{params[:id]} not found."
	     logger.error message
	     redirect_to not_found_url, info: message
     end
 + privilage safe

 + logout 
    new,delete session resource

 + cookies 
    由Rails 提供的，可以看成为Hash，每个element 的格式为
    {value: xxx, expires: xxx}
    value 是文本值
    expires 是失效时间

    cookies.permanent[:xxxx] = test_value 会自动把expires 设为20年以后
    
 
 + Unpermitted 看看是不是controller的parmar 私有方法没有改变

 + CSRF
  #protect_from_forgery with: :exception
  protect_from_forgery with: :reset_session
   delete 时产生的原因
   模板生成错误
    - csrf_meta_tags
     改为
    = csrf_meta_tags

Tools
----------------------------
generate scaffold Produce (单数) 
     生成的modelClass 为Produce, db table 为produces(复数)
generate module Produce (单数) 

Bundle
 一个自动安装分析rails app所依赖的gems 的工具
 Rails 本身依赖Bundle， 所以安装Rails的时候就已经自动安装bundle了

Gemfile
 可以制定一个环境
  .e.g group :development do
          gem xxxx
       end
       group :development, :test do
          gem xxxx
       end
   从git仓库，需要有xx.gemspce 文件
    gem 'carrierwave', github: 'jnicklas/carrierwave'
    gem 'carrierwave', github: 'jnicklas/carrierwave', ref => '339e'
    gem 'carrierwave', github: 'jnicklas/carrierwave', tag: 'xxx'
    gem 'carrierwave', github: 'jnicklas/carrierwave', branch: 'xxx'

   load gem from local file system
     gem 'xxx', paht: '~/xx/yy'

bundle install --without test
bundle package
     package all gems to vendor/cache
    再次安装就会直接使用vendor/cache中的安装, 用于离线安装
     bundle install vendor/cache/*

rake doc:app # 生成文档
rake state  # 代码统计


## 权限限制
使用 before_filter 回调方法实现
通关添加admin 字段来检测是否有相关权限

## Ruby 使用module 来打包一系列函数


## session
一个hash 数据结构，Rails内建了session变量
使用一个32-len string作为id
档一个session创建后，server端会自动在发往client的cookie中填入这个session的id
session中只应该存放简单的string或这数字
session的存储方式
  配置文件
   config/initializers/session_store.rb << EOF
                config.session_store :active_record_store
		EOF
1. cookies, 默认有4k limit 现在，并且能被用户看到
2. 使用active record
   1. rake db:sessions:create
   2. config.session_store :active_record_store
3. 使用memcache
   2. config.session_store :active_record_store

session hash算法 
session_options[:digest] = 默认是SHA1, 也可以是OpenSSL支持的其他算法


清除session
    reset_session

## cookies
#在view 和helper中访问cookies
  class MyController < ActionController::Base
     helper_method :cookies

cookies[:list_mode] = "xxxx"
cookies[:list_mode] = {value:'xxx', :expires => 5.minutes.from_new}
cookies.delete :key

通过cookies.permanent[:xxx] 来设置的value 自动有20年的有效期

## asset pipeline
# 所有的资源都需要在清单文件中列出,只有列出的才能找到
#
# 查看当前的assets 搜索路径, 默认有三处app/assets lib/assets, vonder/assets
#  所有在这三个目录下的子目录会自动被Rails查找
#
# * Rails.application.config.assets.paths
# * 添加查找目录
#
# 每个controller 都有一个对应的js 和 css 文件
# 在这些文件里面写入以后,必须在application.js/css 中 =require 对应的文件才能使用
#
# 引入一个包以后要加入js文件 安装pipeline的所搜路径指定需要的js文件的名字就好
# e.g. 引入 ace.js文件
# //= require ace-builds/src-min-noconflict/ace
#
#//=require_directory [路径] 将路径下，不包含子目录的文件按照字母顺序依次载入。
#//=require_tree [路径]  将路径下的文件，包含子文件夹中的js文件全部载入 
#= require_self 是引用当前文件，一般是application
#
#EE index file 模式
# 可以给一个大的库指定一个index.js 清单文件,里面包含需呀引用的这个库的子模块
# 然后要引入这个库时,就可以只引入这个清单文件即可
# e.g. vendor/assets/jquery/index.js
#   =require jquery 即可
#    

## 预编译在生成环境中使用,放在public/assets 目录下
# rake assets:precompile RAILS_ENV=production ## 主要需要指定production才能开启压缩代码
# 如果出现undefine method [] nil 错误, 把app/assets/style/下面所有的文件都改为.css.scss结尾
#

##image
#图片可以直接放入public文件夹,
# 然后直接在view 中img src="name.png" 就可以引用
#可以

## login
* 实现机制
  把session 作为一个resource, 上线就是create session
     线下就是destory session
  使用cooke 存储
   Session 的作用， 有model 吗?

   1. 创建session Server端给client 生成一个seesion_token
   2. Client 把seesion_token 存到cooke 中，
   3. 每次发送请求，连带发送cooke 中的session_token 
   4. Server 每次处理Request 时，先比较seesion_token 是否正确
         如何比较???

   Rails 内建了一个session 变量
   e.g. user
        user_session

     每个session中都有一个 session[:session_id]
     在 user model 中添加一个session_id 自动
      每次用户上线后就
      session[:user_id] = 


* 密码验证
* 访问控制 实现
   当用户登录时，创建session
      sessin里存放当前的 user_id
      e.g. 
      session[:seller_id] = @seller.id

      logout 就是删除对应的session
  def logout
    session[:seller_id] = nil
    redirect_to login_new_path, notice: 'Logout successfully'

  end

  def user_authenticate
    if user_loggedin? 
      Rails.logger.debug("authentication_ is user_loggedin #{@current_user.id}")
    else
	    ## 传递一个当前页面的url给登录页面，作为登录后的跳转页面
      redirect_to login_users_path(return_url: request.original_url), notice: '请登录系统'
    end
  end

    写一个authenticate -> bool 的函数用来做登录认证
    实现 current_user fn 返回一个User的obj

def current_user
 return unless session[:user_id]
 @current_user ||= User.find(session[:user_id])
end

def logged_in?
  current_user.is_a? User
end

def authenticate
  logged_in? || redirect_to login_path
end


     

* 安全措施
  避免会话劫持，只能全站开启SSL
  因为登陆的remember_token 也记录在cookies 中


## rails app starup
1. config/boot.rb sets up Bundler and load path
2. application.rb loads gems
3. environment.rb runs all initializers


## Erb
<%和<%=不太一樣，前者只執行不輸出，
像用來迭代的each和end這兩行就不需要輸出。而後者<%= 裡的結果會輸出給瀏覽器。

## Module 在Rails 中一个module 会自动的映射到一个数据库table, table
  的名字就是module 的class 的名字复数

## create new app
rails new <AppName>

## config
  config/databse.yml 来配置DB的
   
   Time zero
   config/application.rb config.time_zone= ?

运行 rake time:zones:all OFFSET=+8
显示所有+8时区
在db中还是存的UTC时间

不要用time.now 这个时间是根据系统当前时间
使用time.zone.now

## 18n 国际化
#  和android 相同，给每个字符串对应不同的local定义值/ config/locales/xx.yml
#  在其他地方使用I18n.t ('stirngKey') 
#  在 view 中使用 t('stringKey') 来引用value
#
#  代码以的标签都是英文，
#  每一个语言都有一个local文件，把这些文字翻译为对应语言
#
#  local文件 Rails 会自动加载config/locales/下面的所有.rb .yml文件
#  添加加载路径　config.i18n.load_path += Dir[Rails.root.join('my','locales', '*.{rb,yml}'.to_s]
#
#  设置默认语言
#    config.i18n.default_locale = :zh
#  

## trun on cache response
 config/environments/development.rb
  config.action_controller.perform_caching = true

## rake log:clear
#    

### 生成脚手架
  rails generate scaffold TableName<单数形式> FieldName:Type FieldName2:Type2

  如果已经生成了scaffold 但是有给model 添加了新的字段
  可以再次使用scaffold --skip-migration 来给view 添加新的fields

   这会生成 app/models/TableName.rb
            app/views/TableName/...
            app/controllers/TableName_controller.rb
               ......
            db/migrate/Timesteam_create_TableName.rb

使用 rake 命令来应用migration
  rake -T 查看所有选项

      e.g. rake db:migrate
             这个命令会应用所有还没有被应用migrateions to database

            ake db:rollback
	    rake db:migrate:status

Migration 搭配的 Rake 任務

    rake db:create 依照目前的 RAILS_ENV 環境建立資料庫, 创建db
    rake db:create:all 建立所有環境的資料庫
    rake db:drop 依照目前的 RAILS_ENV 環境刪除資料庫
    rake db:drop:all 刪除所有環境的資料庫
    rake db:migrate 執行Migration動作
    rake db:migrate:reset 用了清除　NO FILE 问题
    rake db:migrate:up VERSION=20080906120000 執行特定版本的Migration
    rake db:migrate:down VERSION=20080906120000 回復特定版本的Migration
    rake db:rollback STEP=n 回復上N個 Migration 動作
    rake db:version 目前資料庫的Migration版本
    rake db:seed 執行 db/seeds.rb 載入種子資料

* 如果执行失败可以是使用　
  rails destroy scaffold <Name> 撤销操作

## model ActiveRecord
#使用不同的DB， 兼容性不是很好，所以在测试的时候就使用和生产环境一样的DB
rails 会自动添加id 字段作为primary-key
run 'rails g model' 查看选项 

N+1 使用includes
users = User.includes(:address).limit(10)

继承后， className 和db tableName 之间对应为单数-> 多数. Book -> books
可以显示设置
 class Book < ActiveRecord::Base
   self.table_name = "xxx"
   self.primary_key= "_id"

   def name 
     read_attribute(:name) || 'n/a'
   end # 没有数据时返回 'n/a'

   def name=(n)
     write_attribute(:name, n + '.com') 
   end 

   ## 等价的可以这样写
   def title
     self[:title] || 'n/a'
   end

   def title=(t)
     self[:title] = t + ' .com' 
   end
 end

config
   可以在application.rb 中设置全局配置
   primary_key_prefix_type
   table_name_prefix
   table_name_suffix
    
模型层的属性设置
  并不使用实例变量， 通过read_attribute, write_attribute 来设置
e.g.


生成model 后,并没有产生db table, 这时可以修改参数, 直到调用 db:migrate 后
 才会生成db table

  有一个可选的hash 
      t.integer :bar_code, null:false, unique: true



  unique index add to Model file
  add_index(:<tableName>, [:bar_code], unique: true) //注意这个函数是DB级别的现在
                并且需要写在 migrate文件中，而不是Model.rb 文件中定义


## Database db
#
# database 都在 config/databse.yml 中配置
#  Rails 在不同环境中使用不同的 DB, 如 development, test, produce
#  使用ORM 模型
#  每个module 就是一个table
#  
#    每个colum 就是一个对象的属性
#  Active Record, 就是一个row

# 添加db 测试数据
# Gem faker
 
# 分页get, 分页显示 ???
# Module API 如何支持分页拉去
# 
# Gems
# 
# 写自己的gem
# rails g plugin <Name>
# 
#   will_paginate
#     对所有module 都添加了　.paginate 方法
#     需要把controller 中的index Action 中的.all 方法换成
#     .paginate
#     e.g. @users = User.all
#          @users = User.paginate(:page => params[:page], :per_page => 20)
#     
#     在view 中如果需用显示分页连接需要加入 <%= will_paginate @users %>
#     Qus. page 的总数量等如何在view 中取得??
#     
#   bootstrap-will_paginate
#   
# Ajax 如何请求???
# 
#

## scope
#   有一个defualt_scope 是只要定义会回自动调用的
#   
#   Named Scope
#  可以自定义ActiveRecord 导出func
#  scope :recent, lambad {order('updated_at DESC')}
#  e.g. xx.recent eq xx.order('updated_at  DESC')}

## rails dbconsole
  进入db 控制台

API
+ XX.new -> object()
+ XX.create == XX.new + obj.save
+ XX.first 具体是哪个要看排序的顺序
+ XX.last  反方向排序的first
+ XX.all
    如果先让返回按某个字段排序
    default_scope lambda { order('categories.name')}
      相当于编程　all.order('xxxx')
+ XX.find_by_FieldName
+ XX.count
+ XX.count_by_sql
+ XX.delete(Id) 也是删除,只不过不需要先find 在调用 destroy
   不会加载data
  DELETE FROM Tab WHERE Key=(Id)
   返回删除的个数
+ xx.find_by_sql("select * from xxx") 使用SQL语句查询
+ XX.select(:fieldName1, :fieldName2) 等于是XX.all 然后只返回你指定的fieldName
      用来过滤希望返回的信息
       e.g. XX.where(xxxxx).select(yyyy)
+ XX.where(:title => 'RailsConf').first
+ XX.where(:title == 'RailsConf').first
+ XX.limit
+ XX.offset 必须和limit一同使用，制定跳过的返回结果的个数
+ XX.exists?
+ XX.uniq
+ XX.arel_table 得到一段查询语句生成的SQL
   e.g.
     u = User.arel_table
     u.where(u[:login].eq("mack")).to_sql

+ XX.destroy  先find在delete
    find(id).destroy
     返回[obj,..] 如果找不到就会产生异常

+ connection
  ActiveRecord::Base.conection

+ obj.valid? 验证有效性，使用model定义的验证函数
+ obj.new_record?
+ obj.persisted?
+ obj.attributes
+ obj.save -> bool()
+ obj.update_attributes(Hash) 编辑和save 一起完成
+ obj.destroy 
+ obj.find(Id) return ???
+ obj.reload.FieldName overcover new value use db value
+ obj.update_attributes(Hash) -> bool()
  
has_many XXX 会自动导出
   obj.xxxs
   obj.xxxs=
   obj.xxxs << 
   obj.xxxs.delete
   obj.xxxs.empty?
   obj.xxxs.size
   obj.xxxs.ids -> list(id)
   obj.xxxs.clear 设置对应的xxx 的foreign_key null
   obj.xxxs.find
   obj.xxxs.build
   obj.xxxs.create


belong_to YY 会导出
obj.yy

has_one XX 会自动导出
 obj.XX
 obj.XX=
 obj.XX.nil?
 obj.build_XX(Hash)
 obj.create_XX(Hash)

# 多态关联
#  polymorphic: true

## callback
  around_save :list_to_json
  after_initialize :json_to_list

  # 存入json格式到DB, 但是obj持有ruby 原声格式list
  def list_to_json
    list  = signed_student
    self.signed_student = signed_student.to_json
    yield
    self.signed_student = list
  end


Megirate
  
不想要id
create_table :name, id: false do |t|
end

改变id名字
create_table :name, id: :xx_id do |t|
end

t.column(:name, type, options={})
t.<type>(:name, option={}) 
   <type>:
    (string, text, integer, float, decimal, datetime, timestamp, time, date, binary, boolean).
  options:
   default
   limit
   null: false

t.index(:column, unique: true)
t.belongs_to

rails给通用的类型定义了type,有对每个特殊db，定义了自己的type
可以查看 NATIVE_DATABASE_TYPES, 来查找类型映射

每个选项都有, null, default, limit 这三个可选参数

* 自定义主键
t.integer :id, primary_key:true, null:false, 不顶用
t.primary_key :id #不能使用, limit:8

* 不通过model 直接执行sql 语句
  s = ActiveRecord::Base.connection.execute("SELECT * from users")
  s.each(:as => hash) do | row |
    puts row
  end

mysql 可以这样制定主键的类型
  在最后重新设置:id 的类型
    change_column :users, :id, :integer, limit:8
    这样就去掉了auto_increment


t.primary_key :name # ok 但是类型为integer
 对于其他类型，需要
   t.string "otherId", null: false
   add_index "table", "otherId", unique:true


dump to DB TABLE struct SQL to file
rake db:structure:dump


* default all fields can be access
   if you want limit it. can be use attr_accessible FieldName
     e.g.  attr_accessible :name, :email

* defalut value
      t.integer :points :default => 0

      save file && rake db:migrate

references :xxx 等效于 integer :xxx_id
  注意是单数形式
   如果在脚手架设定 references 则会生成，对应的外键关系
     e.g.
      t.references :ware, index: true, foreign_key: true
   定义references table, 而不是 table_id , _id rails 会自动添加


  add_references/ add_belogs_to 和add_foregin_key 是一样的，最后都调用
  add_foregin_key
* add_foregin_key
    e.g. add_foregin_key :books, :users
     will add a'user_id' to books
    e.g. add_foregin_key :books, :users, name: :my_user


associations
--------------------------------
定义这些会让Ｒａｉｌｓ导出合适的ＡＰＩ，　
Ｒａｉｌｓ会自动生成合适的ＳＱＬ语言来查询对应的ｔａｂｌｅ

* belongs_to : <tableName>单数形式
* has_many : 
   加这定义的作用?
     自动生成相关联系操作
     Rails 约定 外键的名字由 table + _id 构成
    e.g. aaa.xxxs get  aaa 的all xxx
          aaa has_many xxx(复数)
          xxx belongs_to aaa （单数)

   * xxx Model 本身需要有aaa_id 这个属性用来标记自己属于的aaa
  可选参数
  :class_name
  :conditions
  :foregin_key
  :order  用了指定以xxxs 中的哪个字段来排序返回 e.g. -> {order('fieldName DESC')}
       也可以在指定一个二次排序field e.g. -> {order('fieldName DESC, xxxName ASC')}
       中的参数会附加在SQL 语句中，所以可以写任何DB支持的语句

  :dependent 
     如果要是删除Ａ是ａ的所有ｂ也要确保删除，就是用
     　　　dependent: :destroy
     如果要是删除Ａ是ａ的所有ｂ的a_id 变为NULL 则
     　　　dependent: :nullify

    

* has_one one-to-one parent
  对应的table里的要有本table 的TableName_id field
  约定的名字为 tableName + _id
  可选参数
  :class_name
  :conditions
  :foregin_key
  :order 
  :dependent

* belongs_to :one-to-one/has_many 
     child table 中填写

many_to_many
------------------------------------
  比如数,和种类标签, 类似豆瓣
   一本书可以有多个标签, 一种标签也可以有多本书
   有两种

1. has_and_belongs_to_many 
   使用一个join table 来实现
    has_and_belongs_to_many gives you a simple lookup table which references your two models.
    注意join table 只是一个db table 不是 ActiveModel
    比has_many :through 简单,但是很多实际的问题并不能解决

     has_and_belongs_to_many :students, join_table: :courses_register_students

     e.g.
       class CreateArticlesCategories < ActiveRecord::Migration
         def change
           create_table :articles_categories, :id => false do |t|
             t.references :article
             t.references :category
           end
         end
         def self.down
           drop_table :articles_categories
         end
     end

     如何添加关系(给join_table 中添加数据)
      <<
      user = User.find(params[:id])
      promotion = Promotion.find(params[:promo_id])
      user.promotions << promotion

      删除
      user.promotions.delelte(promotion_id)
   

2. has_many :through
     一般用来多对多
     通关一个中间Modle 来连接两个Model
      比如 a has_many b, b belongs_to c, b belongs_to a
      则 a has_many c :though b
      e.g.
  has_many :replies, :through => :books, :source => :comments
       

delegate: :method1, method2, to :moduleName
  代理制定的方法

还可以指定是否带有前缀，用于解决冲突
* prefix
delegate: :method1, method2, to :moduleName, prefix: true
 这样产生的代理方法，必须加上 moduleName_

* allow_nil: boolean()
   如果是true， 当代理mehtod为nil时，返回nil, 否则raise NoMethodError
   
      
  
一个module 可以对应多个views,

* before_save
  e.g. before_save {|user| user.email = email.downcase}

## JSON
# 使用ruby 的JSON.prase 可能会保存
# 使用 ActiveSupport::JSON.decode(signed_student)

find
---------------------------------------
* where 条件查找
  Model.where(Field => matchValue)
  where 可以接收纯 SQL语句
   where('created_at <= ?', Time.now) 
   会直接使用SQL 的where 拼接参数
   where('created_at <= ? AND name= ?', Time.now, 'fff') 
   where('created_at between ? AND ?', start, last)
   where 的参数格式不能混用


 
Scope
--------------------------------------------
默认scope 在任何查询中都会自动添加
  e.g. default_scope lambda {order('categories.name')}
    #   User.order('name DESC')
    

具名scope
 e.g. scope :Name, lambda { xxxx }
 然后就可以使用Model.scopeName 调用
    类似一个过滤器, 可以在call chain  中使用


seeds.rb
----------------
这个文件中定义app 总是需要的数据
load seed 'rake db:seed
在这个文件里面 填写需要的数据


如果有更改 seed 使用 db:setup


## error report
obj.save 后如果返回false，
obj.errors[:各个属性] 可以得到这个属性是否有错误
obj.errors.any?
obj.errors.full_messages 有所有错误string组成的[string()]

obj.new_record?
 用了测试obj 以前是否调用过save


obj.attributes


## modify fields
1. create a migrate file
2. type your modifty code
3. run rake db:migrate

Or 
1. run rails g migration FileName option
## add fields
e.g. rails g migrate add_FieldName_to_ModleName FieldName : Type

## delete migration file
rails destroy migration <FileName>

## delete column
## add column 
#.e.g
class UsersRemovePassword < ActiveRecord::Migration
  def change
      remove_column :users, :password
      add_column :users, :password_digest, :string
      #t.column :password_digest, :string
  end
end


## 验证active fields 的有效性, 
#  check when obj.save(), not obj.new()
#  有两种格式，长格式和短格式
#  validates_absence_of :name 长格式　＝＝　validates :name, absence: {xxx}

    validates :title, :description, :image_url, presence: true

    + validates(Hash)  check one or  more model fields is not nil
    + presence: true will check echo fieleds is present. and its contents are not empty.

    + validates_absence_of 验证一个字段必须是blank?的
 
    + 唯一性
       uniqueness: true
        e.g. validates :title, uniqueness: true

    + 满足特点格式,math模式 URL or Mail
        validates_format_of :email, options{}
        e.g.
          validates :image_url, allow_blank: true, format: {
             with: %r{\.(gif|jpg|png)\Z}i, 
             message: 'must be a URL ofr GIF, JPG or PNG image.'
          }

    + 长度
         e.g.    
	validates :password, length: {minimum: 6}
           length: {maximum: xxxx}
        length 的验证可以用于integer类型的属性上，会对该属性to_s 在检length


    + 检测一个参数值包含数值
        e.g. validates :price, numericality: {greater_than_or_equal_to: 0.1}
        e.g. validates_numericality_of :xx_id, only_integer: true
	 可选参数
	:equal_to
	:greater_than
	:greater_than_or_equal_to
	:less_than
	:less_than_or_equal_to
	:other_than
	

     + 在指定的范围内
       validates_inclusion_of :sex, in: %(male, famale), message: 'bad' #sex 必须是male 或者 famale
       inclusion: { in: 0..9 }
       #  范围在in 中制定


     + validates_with OtherClass 交给一个class来验证
        class OtherClass < ActiveRecord::Validator
          
        
        
  has_many :line_items, dependent: :destroy
      has_many, belond_to 
         dependent: :destroy is when delete item, Rails will auto delete has_many items
  使用has_many 就可以定义，不需要在modle 中显示写出来
     
     +   validates_confirmation_of :password 
	    会 产生一个<FeildName>_confirmation 的虚拟属性．在ｎｅｗ的时候必须有，而且内容要和password 相同
	     在view中需要填写对应的confirmation field
	      不一定是password 可以是任何fields e.g. #{fieldName}_configrmation

Rails load 所有的stylesheets at once

## add columns to a model
#   rails generate migration add_XXX_to_TABLE
#   e.g.
#     rails generate migration add_quantity_to_line_tiems quantity:integer



## view
Rails 使用laouts 来控制显示的布局.
  不同的page 都可以共享相同的layouts
* If you layout to a specific controller, you can create a file that name with 
    the contorller name e.g. AAs.html.haml
    + 也可以在 contorller Class 中使用 layout method 指定
      e.g. Class XX < ApplicationContorller
                layout 'LaoutName'
    + 在render 时也可以expilcit without layout   e.g. render :layout => false;

* Rails 根据controller class 的继承关系来寻找match 的 layout

如果局部视图要在多个controller 中公用则需要放在
app/view/shared/  以_ 开头 ,render 中则去掉_
   e.g. _error_messages <%= render error_message %>

   render :type , options
   所有的 render 的模板都是在view 根目录下的
   可以向 render 传递变量
    e.g. render 'form', :title = > 'jfoeif'

    render(:text => string)  
    直接渲染出文本, rails default content_type: text/html,
     you can render(:text 'hello', content_type: 'text/plain')


    render(:inline => string, [:type => "rhtml"|"rxml"])   
       传入的string渲染成模板（rhtml或者rxml）
    render(:action => action_name)   
      直接调用某个action的模板，相当于forward到一个view
    render()   
      默认的的render, 相当于render(:action => self) 

    render(:file => path, [:use_full_path => true|false])  
     使用某个模板文件render, 当use_full_path参数为true时可以传入相对路径

    render(:template => name)  
     使用模板名render，e.x.: render(:template => "blog/short_list")

    render(:partial => name, locals:{xx: xx})  
      以局部模板渲染 没有歧义的情况下，是不需要指定 partial

    render(:nothing=>true)  

   render @Name 的意思是　调用view 中名为Name.class 的模板 _Name.html.xxx 的视图

      如果 是复数 render @books
        则Rails 会自动for_each books 中的每一个book, 调用 _book.html.xx
      渲染一个模板 Names 中的每个对象
        == @books.each do |book|
	     render book
	   end

     render :inline '<%= fef{xxxx} %>'  render

     render nothing
        use :head :http_code equie as render nothing: true, status 401
     
     可选的 options:
         :content_type
	 :layout
	 :status

* redirect_to 
    让浏览器跳转到指定页面
      e.g. redirect_to xxx_path
       redirect_to @xxx 也可以接收一个obj 意思书跳转到这个obj 的show 页面
          等价于 redirect_to(xxx_path(:id=> @xxx))

	可以是一个action 

   redirect_to :back # 掉回到上一页
   redirect_to obj, alert: "message" 在flash[alter] 中添加message
   redirect_to obj, notice: "message" 在flash[notice] 中添加message

   redirect_to "https://github.com/404.html" 可以直接重定向到一个网站页面


    n秒自动跳转
    <meta http-equiv="Refresh" content="2;URL=www.xx.com"/>


   Rails4 中可以注册新的flash 类型，这样就可以在redirect_to中使用注册的类型
	class ApplicationController
	...
	add_flash_types :error
	end



## Controller
#
#
  + generate controller
    generate 可以简写为 g 一般为复数形式

      rails generate controller Name Actions...
        会生成
         app/controllers/Name_controller.rb
         app/views/Name/....

 如何删除一个controller
   rails destroy controller ....

   +  generate controller 可以接收指定的action
       e.g. controller StaticPages home about help

   +  g scaffload_conteroller when mode already exists
  ## create 
   ## form submit
   # form 在create 函数中使用变量 params 包括了所有的提交的参数
   #  e..g
  def create
    render text: params.inspect ## 把params 装换成string 打印出来
    render text: params[:posts].inspect ## 把params 中的指定form 装换成string 打印出来
    #用在view 中访问create 中的变量
    #必须定义成类实例变量
    @posts = params[:posts]
  end

   在提交以后 

      redirect_to @post ## 直接跳转post_url() 所在的地址 会告诉client 发送GET请求

    所有咋
    * 打印render text: params.inspect


## helper
 让在 controller 中定义的方法 view 中调用
* helper_method [:current_user, :logged_in?]
  任何一个controller 的helper_method都可以在任何的view中调用

* 在view 中可以调用在helper中定义的任何函数，和这些函数定义的instance-obj
   controller 不能看见在helper 中定义单函数
   helper 也看不见controller 中定义的任何对象

   但是include 后就可在controller 中使用


## respond_to
根据不同的客户端请求，来相应不同类型的数据
通过request 中的元信息来发现请求的类型, Accept-Type
e.g.
 Action ...
   必须要有变量
 respond_to do |format|
      format.html # do nothing, allow Rails to render index.rhtml
      format.js # do nothing, allow Rails to render index.rjs
      format.xml { renderml => @airports.to_xml }
    end 


* before_action 
 在执行action 之前调用一些函数, 会内联到每个action 里面
  e.g. before_action  :set_member, only: [:show, :edit, :update, :destroy]

     
Form set other attr
    <%= f.text_field :name %>
    <%= f.text_field :name , class: 'xxxx'%>
    <%= f.text_field :name , 'other-attr' -> 'xxxx'%>

     Or 
	class ActionView::Helpers::FormBuilder
	 def inputbox_field(method, options = {})
	text_field(method, options.merge(class: 'inputbox'))
						 end
						    end

* check_box_tag(Name, Value, Checked=bool(), options={})
  
* f.collection_select :college_id, College.all, :id, :name
                      这里college_id 必须设置了belongs_to college
		      :id 是设置存储的信息, 也是select 的value
		      :name 设置显示的信息

## rounter
#作用 把http的请求映射到controller active 上， 自动生产help方法
* rake routes 显示所有的路由路径
* 在view 中得到当前的route

* 设定一个root, root 'store#index', as: 'store'
    as 是定义对应的helper

* resources :products, param: :sku 把默认的:id 改为:sku

* resources :logic_nodes, :only => [:index, :show] 
　　　　　only 用了控制自动生成的helper

* member
   为Restful 添加新的action
   e.g. resources aa do
	  :member do 
	   get :bar
          end
      会生成 /aa/:id/bar

* collection
   和member类型也是添加一个新action 不过这个action对应与整个资源

   e.g. resources aa do
           collection do
             get 'search'
           get 'login', on :collection # 也是相同
           end
      会生成 /aa/search

  resources :ware_categories
    资源命名，一般约定为复数(Rails 机制上并不需要，随便写什么都行)，
    对应的controll class 也应时复数形式，
    映射路径根据 resources 指定的值相同， 不会做任何改变。 映射为的controller
    为resources 的值也相同，就是形式不同， _ 去掉， 小写变大写
     e.g. ware_categories -> WareCategories


  as: 'stroe' 会告诉Rails 创建一个 store_path 得访问方法.
  e.g. get '/teams/search/:query' => 'test#acefef', as: => 'search'
     就可以使用 search_url search_path
   
  * resources :posts
   一个 resources 会自动为这个资源生成符合　ＲＥＳＴ的路由

  定义模式 get ':Controller(/:Action(/:id(.:format)))'
      e.g. get '/test/search/:query' => 'test#action'
    * 括号的意思是，可选参数
    * 每个segment 都是一个参数使用:开头使用/ 分割， 在controller中可以使用
        params[:<SegmentName>] 获得h e.g. params[:id]
        http://test/search/?fjeofj:323?foef:3 
        url ? 后的参数也在params 中
        url 前些参数的时候使用helper_path(:key:value)
	    参数会赋值给:query 变量
	    变量以:开头
    * format 制定返回的格式, 在写rount的时候不需要写出来，Rails会默认所有的都有
              .e.g aici.books/show/1.json
       respond_to 会返回json格式， 如果没有匹配的格式Rails 会返回406
 
      至于匹配哪个格式，是根据format如果有的话，如果没有则根据HTTP
      协议中的Content-Type
    respond_to do |f|
      f.html {render text: 'html'}
      f.json{render text: 'json'}
      f.any {render json: xx} any 匹配Rails支持的其他所有format
    end

     
      f.html {render html: xx}
      f.json{render json: xx}

通过match 定义的需要制定 HTTP method， 使用via
match 'path', to: 'c#a', via: :get
match 'path', to: 'c#a', via: [:get, :post]
match 'path', to: 'c#a', via: :all

可以给路由中的变量添加验证
  get 'ookk/:id' => show, id: /\d+/  #==# 
  get 'ookk/:id' => show, constraints: {id: /\d+/}
       constraints: proc{|req| req.params[:id].to_id < 100} # 还可以是block
       constraints: {subdomain: 'api'}


## subdomain
#/etc/host 首先需要添加子域名
#e.g. 
# 127.0.0.1 api.localhost
# 127.0.0.1 *.localhost

#  如果request.subdome 是空 develement.rb 中添加
config.action_dispatch.tld_length = 0  ## 用来设置子域名从第几个.开始
www.aa.bb.com =0 的情况先
 subdomain = www.aa.bb =0
 subdomain = www.aa =1
 subdomain = www =2





cookies 共享 需要设置：

自定义
lib/subdomain.rb << EOF
	class Subdomain
	  def self.matches?(request)

	    request.domain.split('.').size>1 && request.subdomain != "www"
	  end
	end

	constraints(Subdomain) do
	  get '/',  to: "custom#home", as: 'custom_root'
	end
EOF


  get 'ookk/:id' => show_error, id: /\d+/

 root 'welcome#index' # root 值接受get 请求

* nested resources
   resources AA do
      resources BB
   end
     一般是BB 在逻辑上附属于ＡＡ的，不肯能单独出现的
      比如一个帖子的评论，

   会自动生成nested named routes
    e.g.
      GET POST             AA_BBs_path
      GET PUT/PATCH DELETE AA_BB_path
      GET                  edit_AA_BB_path
      GET                  new_AA_BB_path

    在 view edit 需要传入AA, BB 来告诉
    Rails AA， BB 第嵌套关系
      e.g.  form_for([@aa, @aa.bbs.new]) do |f|
       等价于 form_for (:bb, @aa.bbs.new, url: [@aa, @aa.bbs.new])
        OR    form_for (:bb, @aa.bbs.new, url: aa_bbs_path(aa_id: @aa))


     = form_for([@user, @profile], url: user_profile_path) do |f|

  嵌套子资源的表达，必须传递，父资源和本资源
  e.g. 
  = form_for [@current_seller, @produce] do |f|

  而且不光是form_for 对于子资源的helper函数也要传入两个obj
   = link_to 'Edit', edit_seller_produce_path(@current_seller, @produce)

  [@aa, @bb] eq  aa_bb_path(:aa=> @aa, :id = > @bb)

+ shallow
   R4 之后增加的
  resources :products do
    resources :comment, shallow: true
  end

* Namespace routing
  当在routes 中有namespace :api do

  namespace :api, defaults: { format: :json },  ## 指定默认MIME 类型为json, 默认返回的类型为json, 也就是使用json模板渲染
                  constraints: { subdomain: 'api' }, ## 指定子域名api.xxx.com
		  path: '/'   ## 指定每个请求都是从/开始 ??
		  do
    scope module: :v1,  ## 需要建立api/v1 
      constraints: ApiConstraints.new(version: 1, default: true) do
      # We are going to list our resources here
      resources :users, :only => [:show, :create, :update, :destroy] ##api.xx.com/v1/user/:id
    end
  end


  的时候，Rails会自动的把这个namespace 对应到controller 同名的目录下
  Namespace controller
    rails g controller api/Name
      e.g. rails g controller admin/user
       
       不同的namespace 下可以有相同的controller

      namespace :admin do
        resources :users
      end

    
      admin_users
      edit_admin_user
      new_admin_user
   作用,用于组织一系列逻辑上相关的controller
    生成的rount path_hapler 和嵌套的资源相同

重定向
  get "/foo" , to: redirect('/moo') 


* 非RESTfull 路由形式
* RESTfull 路由形式
     e.g.
    posts GET    /posts(.:format)          posts#index
          POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post GET    /posts/:id(.:format)      posts#show
          PATCH  /posts/:id(.:format)      posts#update
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
GET
 link_to("Index", users_path)
 link_to("Show", user_path(Id))
 link_to("New", new_user_path)
 link_to("Edit", edit_user_path(Id))
  
 link_to 的path 参数可以是一个hash obj, path helper会根据key,
         来取得hash-obj 对应key的值


POST
  form_for @user, :url => users_path, :html => {:method => :post}
    
PUT
 form_for @user, :url => post_path(@user), :html => {:method => :put}


DELETE
 link_to("Delete", post_path(@user), :method => :delet)

resources :xxx
  复数形式
resource :xxx
  单数形式没有 index action 所有的URL-helper 也都是单数的
 不管是单数还是复数， 生成的controller Class都是复数形式
 不过可以 使用controller 指定
  resource :dashboard, controller: 'dashboard' 指定为点数

指定 controller
　默认和resources 同名
     e.g. resources :Name, :contoller => "xxxx"

* 限制动词通过　:except => [xx,xx]
      :only => :create
        可以指定action

* 具名路由
  可以自动生成具名辅助方法，
   + xxs_path, 
   + xxs_url
    RESTfull 形式的资源
   + xx_path(Id) /xx/:id
   + new_xx_path(Id)
   + edit_xx_path(Id)
　　会自动产生具名路由，但是非RESTfull 形式的，则必须手动定义(使用　match)
   e.g.
     get 'static_pages/help' -> get '/help' to: 'static_pages#help'
   e.g. 
     root 'static_pages#home' -> root to: 'static_pages#home'

* set other name with rount
  get '/signup', to: 'users#new' == 
  get '/signup' => 'users#new'

* segment key 的约束
  get ':controller/show/:id' => :show, constraints: {:id => /\d+/}
  get ':controller/show/:id' => :show_error
  get ':books/:id' => "xx#yy", constraints: proc {|req| req.params[:id]}

 可以在segment key中使用通配符 
  get 'books/*others' => "xx#yy"

* scope rount
   主要的避免重复
   get 'auctions/new' => 'auctions#new'
   get 'auctions/edit/:id' => 'auctions#edit'
   post 'auctions/pause/:id' => 'auctions#pause'

   scope controller: :auctions do
   get 'auctions/new' => :new
   get 'auctions/edit/:id' => :edit
   post 'auctions/pause/:id' => :pause
   end

   scope path: '/auctions', controller: :auctions do
   get 'new' => :new
   get 'edit/:id' => :edit
   post 'pause/:id' => :pause
   end

 给helper 添加前缀
   scope as: user do
   end


## traceroute
# 一个工具用来检测是否所有的action 与route 一一对应



Flash
---------------------------------------------
通常是一个acton　set, 写一个action get
当以在本action render 时就要使用可以使用 flash.now[:notice] ="feff"

flash 是 session 的应用，通常在 controller 的 action 间传递信息，读取成功后自动清空。
如果一个 flash 没有在合适得地方读出来，那么它将被保存到读出为止

action
--------------------------------------
Action 中预定义的的变量和方法
* action_name
* headers
* params -> hash
* request
     request.env["HTTP_HOST"]

     request.original_url ,当前页面的url
     request.headers["Content-Type"] 可以获取头部信息
     request.host 
     request.host_with_port
     request.subdomain
     request.protocol # "http://"
     request.remote_host
* session
* redirect_to

render 渲染
--------------------------------
每个action 有默认的render
  如果不要render, 可以指定跳转到另一个页面(使用redirect)

render 的格式，还控制这HTTP response 的content-type 字段


cb
------------------------------------
可以在acton 前后执行指定的回调
都要知道那个对用的action use :only :except
* cd 可以从继承体系继承， 如果父类中有cb 则子类也要调用

* before_action
    一般用于验证

* after_action

* around_action

* skip_before_action

## web  server
* WEBrick
    性能不足，一般用于开发中, 有些功能欠缺
    不要使用有些HTTP的协议没有实现，比如html5 video

* thin 
   使用替代WEBrick 在开发中使用
   很方便，在Gemfile 中添加 
   gem 'thin'
   rails s 会自动使用thin

  thin start --servers 3 -e production
  开启三个进程
  thin -h  查看帮助
 

* unicorn
    ?????

* Puma 
    大家都推荐的生成环境 rails web server

form_for
 建立表单
 e.g.
   <%= form_for @event, :url => { :controller => 'events', :action => 'create' } do |f| %>
    <%= f.label :name, "Name" %>
    <%= f.text_field :name %>

    <%= f.label :description, "Description" %>
    <%= f.text_area :description %>
    <%= f.submit "Create" %>
<% end %>
   # 每个field 的html属性直接写在后面即可
   # e.g.
  .field
    = f.label :name
    = f.text_field :name, placeholder: '请填入产品名'
  :name 等都必须是event 中的属性

simple_format是一個內建的View Helper，
 它的作用是可以將換行字元\n置換成<br />，有基本的HTML換行效果。
  rails g simple_form:install --bootstrap
  然后就可以使用simple_form_for(@xxx, html:{class=<bootstrap-form-class>})


form_tag 用于没有对应obj 的form生成
      = form_tag search_path do
        = search_field_tag 'search', nil, :placeholder=>'Search'
        = submit_tag 'Search'

= form_tag course_stat_teacher_path(current_user), :method => :get
  label_tag 请选择日期:
  input type="text" class="datepicker" name="start"
  label_tag to
  input type="text" class="datepicker" name="end"
  = submit_tag "Submit"
   
   如何得到参数get 还是通过params


* dom_id 用在view 中
  e.g. dom_id(category)
      生成 dom_id  id='category_3'

   

REST
路径
 注意资源的单复数
 show_ , new_ edit_, update_ , destroy_ 
  + <资源名>_path(Instance) 需要参数

 <Resource>s_path 复数不需要参数
 
## application
layout application.html.erb

## 3-thrid
# 放在public 
# root is public
# public 是上线后client 唯一能够访问的地方

## View
#
        <%= link_to 'Home', stores_path %>
* link_to 创建一个超链接
    link_to(Name,Path[,Hash])
          第三个参数是可选的, 用于URL的指定参数
     e.g. link_to "SignUp", '#', class: 'signup'
    如果想指定一个连接的格式可以
     linke_to "xx", path_hapler(@obj, :json)

    link_to 'Back', :back #回退

    link_to "<span class='lyphicon glyphicon-plus'></span>".html_safe, sign_lesson_courses_path(@course, l)
    内嵌标签

     Rails 使用路由的名字来指定连接

## layout
提供统一的布局默认在 views/layouts/application.html.erb
  <%= stylesheet_link_tag    "application", media: "all", "data-turbolinks-track" => true %>
   
  <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
  <%= csrf_meta_tags %>
  <%= yield %>


  『 stylesheet_link_tag 』 這段程式碼意思是 Rails 會把 app/assets/stylesheets 資料夾裡的
.css、.scss檔合併、並壓縮成一個名叫application.css的css檔給網站用
 在develop的情况下不会合并， 并且引用的是application.css中的引入文件

『 javascript_include_tag 』這段程式碼意思是 Rails 會把 app/assets/javascripts 資料夾裡的
.js、.coffee檔合併、並壓縮成一個名叫application.js的js檔給網站用

『 <%= csrf_meta_tags %> 』加入csrf安全機制(詳見這裡)

『 <%= yield %> 』
  没有任何参数的yield会默认rander当前controller#action 的模板

 有参数的 yield :xx ##相当于占了个位置, 把后门在content_for :xx
                    ## 中的内容添加到这里,即时没有:xx 也不会抱错
 需要配合 content_for :xx do
               实际内容
   来使用;
这里的:xx 只是标签,并不是模板文件
  

controller 级别layout tempate
layout 是会被继承的
如果在一个controllClass 中使用了
 layout :xxx
 则会覆盖掉以前的layout

如果在views/layout 中定义一个和controller同名的layout文件,
则会自动使用该文件,

* 如果是希望多态的插入片段
  可以使用 render "filename"
   这里的filename 默认是在当前contrller/view/_filename

  如果是在layout 下面需要指明
  可以使用 render "layouts/filename"
    render :partial "layouts/filename" 形式的简写

## 内置可访问变量
#* assigns
* controller    <%= debug(controller.controller_name) %>
* cookies a hash variable
* flash show message only for the duration of the next request
  常用 flash[:notice]
       flash[:alert] 用于more serious nature
       flash.now 用于在当前页显示信息,而不是下一个页面

    div.flash
      - flash.each do |k, v|
        p id= "#{k}" = v
* logger
* params
* request 应之用于debug
* response应之用于debug
* session


## Ajax
所有的send 都可以使用ajax 的方式
添加 remote: true
这是发声的HTTP请求 Accept 会变为 
   */*;q=0.5, text/javascript, application/javascript, application/ecmascript, application/x-ecmascript
server 端受到后会匹配到js 中
# send a Ajax req
#   add remote: true
#   e.g.  <%= button_to 'Add to Cart', line_items_path(product_id: product), 
#           remote: true %>
#

#server  需要formts.js {xxxxx}
# 因为Ajax 默认的dataType 是script

Rails 的Ajax 一般分为json 和js
js , 是后台返回一个js code, 就是在成功后操作的code, 
    这种叫做服务端Ajax

e.g.
#= link_to 'new comment', new_book_comment_path(@book, :format => :js),
#  :remote => true, :id => 'new_comment_link'
#     这个请求会导致调用 view/comments/new.js.xxx template
#     
#  new.js.erb << 
#    $("<%= escape_javascript render(file: 'comments/new.html.haml') %>").insertAfter('#comments');
#    $('#new_comment_link').hide();
#  EOF


halper 
j() == escape_javascript()

json,后台只会返回一个json 数据, 
    只用json 时要加上　"data-type" => :json

button_to , link_to, form_to 如果加上 remote => true 都会变为Ajax 提交

## passwed  验证 4.1 以后有内置支持
# Use ActiveModel has_secure_password
#  1. model加入 has_secure_password, 
#  2. model 中必须有password_digest 字段
#  3. 提交时必须有: password & password_confirmation. 这两个字段, model中不需要有
#      new 的时候可以只有password, 
#      但是如果有password_confirmation 就要和password 的相同，否则save 会失败，返回false
#      
#   加上后 model 的instance 就会导出一个 authenticate 函数用于验证
#    e.g.
#     
  def create
    user = User.find_by_email(params[:email])
    if user && user.authenticate(params[:password])
      session[:user_id] = user.id
      redirect_to root_path
    else
      redirect_to login_path
    end
  end

f.password_field :password
f.password_field :password_confirmation 

# gem 'bcrypt-ruby', '~> 3.0.0' # provied bcrypt hash func
   ~> 的意思是安装版本号>3.0.0 但小于3.1.0 的版本
  一般建议使用精确版本号，不容易发生错误

Gems
   
+ 权限管理
gem   'cancancan', '~>1.10'
   + cancancan 不关心用的是什么认证机制，他只依赖一个current_user 的方法
     返回user record或者是一个nil


 + rails g cancan:ability
 会生产app/models/ability.rb
   所有的权限规则都在这里声明
ability.rb << EOF
class Ability
  include CanCan::Ability
  def initialize(user) ##这里对user可以执行的操作做设定
       user ||= User.new # guest user (not logged in)

       # 别名
        alias_action :update, :destroy, :to => :modify # 定义所有的update,destroy,等同于modify

       case user.role
       when :admin then
         can :manage, :all #can 是个方法定义在Ability 中
                          # :manage 意思是执行所有的action
       when :root then
         can :new, :Book ## can 用来给每个权限定义可以执行的操作
	                ## can <ActionName> <ControllerClass>
	 can :index, :Book
	 can [:edit, :update], :Book
	 can [:edit, :update], :[Commit, Message]
       else
         can :read, :all ## :read 是cancan自定义的action别名

       end
  end
end
EOF

 + view 
 can? 方法会判断当前user，是否能够执行一个controller 的action
 can? <ActionName> , <ClassName>
 cannot?
  <% if can? :index, Project %>

 + controller
  对每个controller,的action都定义user的访问权限

	def index
	  @projects = Project.all
	  authorize! :index, @project ## authorize用来给每个controller 的action定义
	  在can 中对应的名字
	end
   + 如果不想在每个action中都写authorize! 这句话，可以在controller 的开头写上
     load_and_authorize_resource ## 每个名字都是action的名字



   +捕捉　CanCan::AccessDenied
	class ApplicationController < ActionController::Base
	 # 在ApplicationContorller 中添加
	  rescue_from CanCan::AccessDenied do |exception|
	    redirect_to root_url, :alert => exception.message
	  end
	end

   
+ annotate
  gem 'annotate', '2.6.5'
  generate modele fields type comment in Module.rb
  annotate -p before

+ 前端form 字段检查
    gem 'html5_validators'
   根据ActiveModel 和form_for 自动为每个field生成前端检查

+ bootstrap
   这个有好几个rails的版本
 gem 'bootstrap-sass'
    EOF >> <  application.css.scss 
        @import "bootstrap-sprockets";
        @import "bootstrap";
　　EOF 

    EOF >> application.js
      //= require bootstrap-sprockets 注意在jquery后门
    EOF

    重写bootstrap 参数
    可以在@import bootstrap 之前，对bootstrap 的变量进行赋值
     e.g. $xxx = yyyddd


 gem 'font-awesome-sass', '~> 4.4.0'
    EOF >> <  application.css.scss 
      ## 添加这两行，导入字体
	@import "font-awesome-sprockets";
	@import "font-awesome";
　　EOF 

   <i class="fa fa-NAME"></i>

  Rails helper 
  icon('flag')

  
+ haml
    gem 'haml-rails'

+ autoprefixer
   gem "autoprefixer-rails"
    用于给css 自动添加兼容前缀
  

+ slim
   gem 'slim-rails'

+ 分页
   gem 'will_paginate'


+ Cucumber
  一个流行的驱动开发(BDD)工具
  扩展名为 .feature

+ devise
  Devise为Rails程序提供了一套易用的用户认证方案，
  你可以使用这个Gem实现用户登录，注册，找回密码，
  账户锁定等账户相关的功能。

   流行的权限管理Gem
   uses
     * gem devise
     * bundle install
     * rails g devise:install
     * echo config.action_mailer.default_url_options = {:host => 'localhost:3000'} >> config/devlopment.rb
     * rails g devise:views
     * rails g devise User
     * devise_for :users >> rount.rb
     * rake db:migrate


     自动添加的helpers
     signUP new_user_registration_path
     Eidt Account edit_user_registration_path
     Login new_user_session_path
     Logout destroy_user_session_path :method => :delet

     判断是否login current_user.blank?
     当前登陆者 current_user



gem "devise", '3.2.4'
gem "devise-async", '0.9.0'
gem 'omniauth', "~> 1.1.3"
gem 'omniauth-google-oauth2'
gem 'omniauth-twitter'
gem 'omniauth-github'
gem 'paperclip' 文件上传处理
     要求安装有convert 程序，并且可以调用
     使用在再要存放图像的modele 里面使用

 使用到了file 程序

  EOF >> < config/development.rb
    Paperclip.options[:command_path] = '/usr/bin/' 
  EOF

  EOF >> < <Model.rb>
    ##image 是field 的名字 可以定义大小尺寸
  ## 必须要有 has_attached_file, iamge 是字段的名字
  has_attached_file :image, :styles => {:medium=> "400x600#", :small=> "300x300>"} 

 一旦加入后，table会多出
    t.string   "data_file_name"
    t.string   "data_content_type"
    t.integer  "data_file_size"
    t.datetime "data_updated_at"
  这四个field


  validates_attachment_content_type :image, :content_type => /\Aimage\/.*\Z/
  EOF

  add Model
  rails g paperclip <Model> <field_name>

  View
    = image_tag @recipe.image.url(:medium, class: 'recipe_image')
    = image_tag @pin.image.url(:medium)
     使用obj.xx.url 


upload
  必须设置为multipart/form-data
 <form enctype="multipart/form-data" >
   <input type="file">
   rfc 1896 制定的http上传文件个协议
   表单的每个field使用一个boundary参数制定的分隔符分割


gem 'acts_as_votable', '~> 0.10.0'
  评分系统
  使用
   在model 中添加 acts_as_votable
   然后这个model 就会添加vote 的函数
   在rount, controller 中添加 upvote, downvote 的action
   然会调用model 对应的action
   在view 中显示 vote 值;

    @pin.upvote_by(current_user)
    = link_to like_pin_path(@pin)
    @pin.votes_for.size

    会导出多组函数, like/dislike, up/down 名字不同意义相同


gem coccon 
  Rails中view层的form多层嵌套功能。Cocoon的使用，可以在标准的Rails中单独使用
   也可以结合Formtastic或SimpleForm使用。
   echo //= require cocoon >> application.js

   Model
    has_many :tasks
    accepts_nested_attributes_for :tasks, :reject_if => :all_blank, :allow_destroy => true

   此Gem主要提供了两个辅助方法:
   link_to_add_association
   link_to_remove_association


gem 'masonry-rails', '~> 0.2.1'
   图片显示瀑布流模式
   通过css id .class 来控制

gem 'searchkick' 
   站内搜索
  依赖elasticsearch


gem 'active_merchant'
   在线支付

 
gem 的机制
---------------------------------------------------

## debugger
gem 'byebug'
  调试功能
  在需要断电的地方写入
  debugge
  e.g.
  def index
  debuge
  end
指令和gdb 类似，使用help得到帮助

## show debug info
    = debug(params) if Rails.env.development?


## logger on console
  Rails.logger.debug "sth."

## counter_cache
 用处: 如果一个model A 中有个has_many, xxxs 有需要统计多多少个xxx
       则可以给这个A 添加一个xxxs_count field
       这样Rails 在create 和 destroy 是就会自动更改xxxs_count 这个字段

       在xxx Module 上
       belongs_to :A, :counter_cache => true
        如果要指定名字
       belongs_to :A, :counter_cache => <Name>

## Redis
+ install 
 gem redis

+ connect
  create an initializer in config/initializers/redis.rb and add the following:
  $redis = Redis.new(:host => 'localhost', :port => 6379)


## Rack
#类似与Make
#
#rack --tasks 查看所有任务
#
#在lib/tasks 中定义
#
namespace :my do #可以不要
  task :name do
  end
end

exec
rake my:name

## ActionController::Live
#  r4 内建的用于发送大数据的功能
#   e.g.
#   
#  用来实现SEE server-sent-event
# Streams about 180 MB of generated data to the browser.
include ActionController::Live
def stream
  10_000_000.times do |i|
  response.stream.write "This is line #{i}\n"
  end
ensure
  response.stream.close
end

注意事项;
All actions executed from ActionController::Live enabled controllers are run in a separate thread.
This means the controller action code being executed must be threadsafe.
• A concurrent Ruby web server, such as puma 5, is required to take advantage of live streaming.
• Headers must be added to the response before anything is written to the client.
• Streams must be closed once finished, otherwise a socket may be left open indefinitely.

## VIM rails快捷键
R 大头的
E 开头的用于创建

## MongoDB
#Rails 使用的驱动为
#driver mongoDB 官方提供
#gem 'mongo', '~> 2.0'
#
#ROM associations validations 相关功能
#gem 'mogoid', '~> 5.0.0'
#

## Myslq
#mysql 驱动 
#gem 'mysql2'
#
#使用mysql 需要先创建DB
#config/database.myl >>
development:
  adapter: mysql2
  encoding: utf8
  reconnect: false
  database: xxx
  pool: 5
  username: root
  password: 12345
  host: localhost


## PostgreSQL
#gem 'pg' 
#安装的时候如果编译失败,
#1. apt-get install postgresql-server-dev
#2. ARCHFLAGS="arch x86_64" gem install pg
development:
  adapter: postgresql
  encoding: unicode
  database: myapp_development
  pool: 5
  username: myapp
  password: password1

test:
  adapter: postgresql
  encoding: unicode
  database: myapp_test
  pool: 5
  username: myapp
  password: password1

rake db:create

## stamp
# date 格式化
# gem stamp
# ruby 原声data和times类型会导出一个 satmp方法


## 生成环境部署
首先 ror 是单线程的server， 一次只能处理一个请求。 
 这意味着，如果一个请求卡住，后门的请求只等等待

所以在部署的时候，会把ror放在 Apache/Neginx 的后门，只有需要ror处理的时候
这些web-server 才发给ror.
* 通过Passenger 代理, ror 可以一次开启多个实例

## exception
# 使用rescue_from 来在controller scope 中handle制定的异常
# 
  def log_exception(exception)
    application_trace = ActionDispatch::ExceptionWrapper.new(env, exception).application_trace
    application_trace.map!{ |t| "  #{t}\n" }
    logger.error "\n#{exception.class.name} (#{exception.message}):\n#{application_trace.join}"
  end

## RSS / ATOM
 auto_discovery_link_tag
 或者是 link_to "rss", xxx_path(format: "rss")
  在对应的action中提供rss 格式的数据

## UJS
#  rails 使用 unobtrusive js 技术
#  
  .actions = f.submit nil, :data => {"disable-with" => "请稍等..."}

# gem default_value_for
# 给activeRecord 声明一个默认值
class User < ActiveRecord::Base
  default_value_for :name, "(no name)"
  default_value_for :last_seen do
    Time.now
  end

default_value_for :age do
    if today_is_sunday?
      20
    else
      30
    end
  end
end

u = User.new ## new 出后就有默认值了,只是在AR 层面,并不是db colnum
u.name       # => "(no name)"
u.last_seen  # => Mon Sep 22 17:28:38 +0200 2008


## defore_action :call [,option]
# 注意defore_action 对返回值并不关心

## Gem mini-profiler
# 性能分析工具
# 

## Gem gullet
# 分析所有的N+1 db 操作

* Gem brakeman
  安全分析工具

* Gem rubyocop
  一个语法style 静态分析工具

##EE Gem browser
#浏览器类型发现

##EE Gem acts_as_votable
# raddit 风格的投票系统

##EE Gem gollum-lib
#built ont git wiki system
#安装完后,还有根据所使用的文档类型,安装文档解析gem
# e.g. gem wikicloth

## icon identicon github style 
#  gem 'identicon'
#  使用 
  <%= image_tag(Identicon.data_url_for(@user.name, 128)) %>
  会自动生成内联的img data

  Identicon.file_for "User's email? Username? Telephone?", "/path/to/the/image"
  生成图片文件

还有一种是使用纯前端的cavase 来生成图片

## bower-rails
# rails的bower 集成
# gem "bower-rails", "~> 0.10.0"
# 1. 生成配置文件 bower.json
#   rails g bower_rails:initialize json
# 2. zai bower.json里面写入需要的js包名
#
# 3. 下载
#   rake bower:install
#   默认会下载到vendor/assets/bower_components
#
# 4. 添加asset pipeline
#  默认会把vendor/assets/bower_components 自动添加到资源搜索路径
#  config.assets.paths << Rails.root.join("vendor","assets","bower_components")
# 
# 5. 在application.js 中添加
# //=require Name/js
#
# 6. 需要重启server
#

# gem gem "bower-rails", "~> 0.10.0"
# 首先执行 rails g bower:initialize json
# 会生产两个文件,一个配置,一个插件文件bower.json
#  需要什么包就在bower.json中写入,然后执行 rake bower_rails:install
#  默认安装在vendor

## jquery-ui
# gem jquery-ui-rails
# 使用
#  引入js/css 文件
#  
$(document).ready ->
    $("#datepicker").each ->
        $(@).datepicker
          dateFormat: "yy/mm"

## API
#使用 active_model_serializers 在model　层得到json格式数据
gem 'active_model_serializers'  
   

　　
